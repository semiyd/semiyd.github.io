<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="================================================================================================ 中断：    一般在设备open的时候才开始request_irq，同理在close时候才free_irq    int request_irq(unsigned int irq, irq_handler_">
<meta property="og:type" content="article">
<meta property="og:title" content="Semiyd&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/2021/03/21/中断/index.html">
<meta property="og:site_name" content="Semiyd&#39;s Blog">
<meta property="og:description" content="================================================================================================ 中断：    一般在设备open的时候才开始request_irq，同理在close时候才free_irq    int request_irq(unsigned int irq, irq_handler_">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-03-21T06:50:20.283Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Semiyd&#39;s Blog">
<meta name="twitter:description" content="================================================================================================ 中断：    一般在设备open的时候才开始request_irq，同理在close时候才free_irq    int request_irq(unsigned int irq, irq_handler_">






  <link rel="canonical" href="http://yoursite.com/2021/03/21/中断/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title> | Semiyd's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Semiyd's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/21/中断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Semiyd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Semiyd's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2021-03-21 14:50:20" itemprop="dateCreated datePublished" datetime="2021-03-21T14:50:20+08:00">2021-03-21</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>================================================================================================</p>
<p>中断：<br>    一般在设备open的时候才开始request_irq，同理在close时候才free_irq<br>    int request_irq(unsigned int irq, irq_handler_t handler,<br>                         unsigned long irqflags, const char <em>devname, void </em>dev_id)<br>        irq号是分两种情况：<br>            1.直接对应硬件中断号<br>                这种情况就是某功能模块产生的中断，比如i2c,以太网，等等。和cpu的硬件中断号一致。<br>                通常在执行request_irq之前，会用platform_get_irq()从resource{}里面取出中断号。<br>                这个resource{}里面的中断号，来自CPU的spec的硬件定义。以AT91SAM9x35为例，在spec的Table 8-1. Peripheral Identifiers里面写明了。<br>                又以am3354为例，cpsw以太网中断。cpu的spec的Table 6-1里面写明是40.实际cat /proc/interrupts也是40.<br>                因为am33xx_cpsw_resources[]里面定义的就是40，这个定义来自于irqs-33xx.h<br>            2.软件中断号<br>                这种情况就是比如某gpio产生的中断，用<br>                irqs-33xx.h<br>                现在tq的板子上试试drivers\input\keyboard\gpio_keys.c        gpio_keys_isr()    am335x_mmc[]     omap_hsmmc.c    omap_hsmmc_irq()<br>                然后再来修理iq8的jtag线的问题，先换一块v2.1的dsp的板子</p>
<pre><code>        中断处理流程是：
            arch/arm/kernel/entry-armv.S        irq_handler
            arch/arm/mach-omap2/irq.c            omap3_intc_handle_irq
            arch/arm/mach-omap2/irq.c            omap_intc_handle_irq
            arch/arm/kernel/irq.c            handle_IRQ
            kernel/irq/irqdesc.c                generic_handle_irq
            include/linux/irqdesc.h            generic_handle_irq_desc
            kernel/irq/chip.c                handle_level_irq
            kernel/irq/handle.c                handle_irq_event
            kernel/irq/handle.c                handle_irq_event_percpu
            drivers/mmc/host/omap_hsmmc.c        omap_hsmmc_irq
            request_irq的irq号入参是64和166.


        gpio_to_irq()执行流程：
            gpio_to_chip
            gpio_2irq
                virtual_irq_start=192加上offset
            drivers\input\keyboard\gpio_keys.c    gpio_keys_setup_key
        可以通过cat /proc/interrupts来看已经注册的中断号。并且第二列表示中断被触发的次数
            [root@Honeywell /proc]# cat interrupts
                       CPU0
              4:          0      INTC  omap2_elm
             68:       1863      INTC  gp timer

        另外，对于需要在中断处理程序里面，去读取中断线本身的高低的情况。需要这么做：
            1.gpio_request(irq_gpio)
            2.gpio_direction_input(irq_gpio)
            3.request_irq(irq_gpio)
            经验表明，如果先request_irq，再去gpio_request和gpio_direction_input，会导致之前request_irq注册的中断失效，从而进不了中断。


    handler是向系统注册的中断处理函数,中断发生时，系统调用这个函数，dev_id参数将被传递给它
    irqflags是中断处理的属性
    devname设置中断名称
    dev_id在中断共享时会用到，一般设置为这个设备的设备私有结构体

static inline int __must_check devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
     unsigned long irqflags, const char *devname, void *dev_id)
    新版内核有这种devm_开头的API，意即device managed。意思是不再需要在出错处理和驱动的remove接口中做free_irq()的释放动作。内核会自动处理。
    （IRQs requested with this function will be automatically freed on driver detach.）
    类似java的垃圾回收机制。
    类似的devm的接口还包括devm_kmalloc。通常放在probe里面。在module_exit的时候，资源会自动释放。

int request_threaded_irq(unsigned int irq, irq_handler_t handler,
         irq_handler_t thread_fn, unsigned long irqflags,
         const char *devname, void *dev_id)
    申请线程化中断，中断服务程序是在线程里执行的。thread_fn就是具体线程执行的函数，放在kernel thread 里面执行。
    这个API的引入是为了提高kernel响应速度，把尽量多的事情放在线程thread_fn里做，而在中断里执行的handler部分则尽量用NULL来减少硬中断的执行时间。
    现在linux社区想要慢慢把tasklet给淘汰掉。
    在这个API出现以前的传统的方式，中断处理被分为顶半部分（也就是所谓&quot;hard&quot; irq）和底半部分（也就是所谓&quot;soft&quot; irq）
    顶半部分执行的时候，中断是关闭的。所以顶半部分做的事情越少越好。
    剩下的事情交给底半部分去做。
    有关request_threaded_irq的入参handler，有两种情况：
        1.handler入参为NULL（通常情况）
            当中断来了以后，内核会用默认的irq_default_primary_handler()代替handler，其实也就是直接返回IRQ_WAKE_THREAD，然后就直接呼叫调度thread_fn
            并且内核此时自动会使用IRQF_ONESHOT标记，也就是在thread_fn()执行结束之前，中断是不会开的。
            注：从2012年开始，比较新的内核，是不允许在handler为NULL的情况下，不加IRQF_ONESHOT标记的。理由是，如果中断是电平触发，不加IRQF_ONESHOT
            会导致中断不停不停的进来，因为handler一结束中断就开了，handler因为是默认的，只会直接返回，执行的很快，而电平的状态还保持着。    
            而加了IRQF_ONESHOT，则会等thread_fn结束中断才开。比较安全。
            至于边沿触发，其实并无这种危险。但保险起见，一棒子打翻船，后续的内核版本就禁止了在无handler且无IRQF_ONESHOT的情形。
            如果违反，request_threaded_irq会出错退出，返回EINVAL，且会打印出下面这句话：
            pr_err(&quot;Threaded irq requested with handler=NULL and !ONESHOT for irq %d\n&quot;, irq);        来自kernel\irq\manage.c
            参见http://www.spinics.net/lists/linux-tip-commits/msg14974.html
        2.如果handler不是NULL，则执行完成必需的工作以后，需要返回IRQ_WAKE_THREAD，内核会调度thread_fn执行。
    现在传统的request_irq()其实内部也是调用request_threaded_irq，只是thread_fn是NULL
     这个API，和传统的顶半部分+底半部分比较大的区别是：
    不需要像传统的顶半部分一样，在执行结束的时候，通过类似queue_work这种调度的API，来调度底半部分。并且因为不要调度，所以无需在top/bottom之间做同步和加减锁的动作。
    顶半部分可以直接设置成NULL。多少要快些，中断的处理。
    相比之下，workqueue的overhead较大，而tasklet更是不能睡眠。
    参考Linux\Kernel\学习资料\Moving interrupts to threads [LWN_net].pdf

int request_any_context_irq(unsigned int irq, irq_handler_t handler,
            unsigned long flags, const char *name, void *dev_id)
    这个API的使用范围尚不明确，在4.1.18内核里，用的人也不多。
    这个API会根据中断控制器本身的“上级”中断是否为threaded_irq来决定采用request_irq注册还是采用request_threaded_irq注册中断。
    从这个API内部做的事情来看，就是通过irq_settings_is_nested_thread来判断，
        是用request_threaded_irq还是用request_irq来注册中断。
        具体是将入参handler作为thread也就是底半部分执行，还是将入参handler作为顶半部分执行。
        而irq_settings_is_nested_thread所检查的标志位IRQ_NESTED_THREAD，是由irq_set_nested_thread来设置的。
        调用irq_set_nested_thread()的，一般都是mfd驱动所调用的，比如pmic的芯片驱动
    后续有空再研究。可以看看那些使用request_any_context_irq的驱动，有什么共性？
    参考文档：Linux\Kernel\学习资料\Introduce request_any_context_irq().pdf

int request_percpu_irq(unsigned int irq, irq_handler_t handler,
           const char *devname, void __percpu *dev_id)
    和多核cpu中断处理有关，后续有空再研究。


禁止中断
disable_irq()关闭中断并等待中断处理完后返回。所以如果在n号中断的顶半部分调用disable_irq(n)，会引起系统死锁。这种情况应该调用disable_irq_nosync()
disable_irq_nosync()关闭中断，不等待中断处理完立即返回。这个适合在中断处理函数内部关中断使用。
disable_irq_wake()        和enable_irq_wake()对应
以上三个API,可以用来关闭某个特定的中断，例如某个gpio中断。
local_irq_save(flags)    在本CPU内，禁止中断，并将中断状态保存在flags中（unsigned long类型）
local_irq_disable(void)    在本CPU内，禁止中断，而不保存状态
local_bh_disable()        在本CPU内，禁止中断的底半部
以上三个API，用来全局的关闭本cpu的中断。

启动中断
enable_irq()
enable_irq_wake()    将某个中断设置成可以唤醒系统，即把系统从低功耗模式中唤醒，如从suspend to RAM中唤醒。 （此API并非使能中断，仅仅是使能中断唤醒功能）
local_irq_restore(flags)    和local_irq_save(flags)对应
local_irq_enable(void)    在本CPU内，使能中断，而不保存状态
local_bh_enable()        在本CPU内，使能中断的底半部（也就是关抢占）

有关local_irq_save与local_irq_disable的区别：
    假设在调用这两类API之前。有一个中断号x已经被禁止的。
    此时如果调用local_irq_disable，然后调用local_irq_enable。则会导致之前被禁止的中断x重新被启用。这样可能是危险的。
    而local_irq_save会在关闭中断的时候，保存之前中断的状态，例如这个x是需要禁止的。这样local_irq_restore(flags)的时候，就不会意外启用中断x。
    另外，之所以local_irq_save(flags)能够直接传递值给其入参flags，是因为它是个宏，而不是函数。

底半部分的机制之    tasklet / Work queue / Softirqs / threaded irq
    在linux里，中断处理分为顶半（top half），底半(bottomhalf)，在顶半里处理优先级比较高的事情，要求占用中断时间尽量的短，在处理完成后，就激活底半，有底半处理其余任务。
    底半的处理方式主要有soft_irq,tasklet,workqueue，threaded irq四种，他们在使用方式和适用情况上各有不同。
    threaded irq上面已经介绍过。
    soft_irq用在对底半执行时间要求比较紧急或者非常重要的场合，主要为一些subsystem用，一般driver基本上用不上。
    tasklet和work queue在普通的driver里用的相对较多，主要区别是tasklet是在中断上下文执行,而workqueue是在process上下文，因此可以执行可能sleep的操作。
    注意：默认情况下，所有底半部分，包括软中断的回调函数，都可以被硬中断打断。
    Softirqs和Tasklets
        Tasklets是Softirqs的包装。两者基本相同，不同之处是Tasklets/workqueue不可重入，Softirqs可重入
    tasklet                     Work queue                            Softirqs
    处于atomic context,不能sleep        不处于atomic context,可以sleep                    处于atomic context,不能sleep
    处于中断上下文，OS不可以进行进程调度    处于进程上下文，OS可以进行进程调度                处于中断上下文，OS不可以进行进程调度
    运行调度它们的同一个CPU上        默认同一个CPU上，可以同时运行于多个CPU上                可以同时运行于多个CPU上
    不能指定确定时间进行调度            不能指定确定时间进行调度或者指定至少延时一个确定时间后调度
    只能交给ksoftirqd/0            可以提交给events/0，也可以提交给自定义的workqueue            只能交给ksoftirqd
    Tasklet函数带参数                Work函数不带参数
    接着top half 直接执行

    具体API:
        tasklet:
            DECLARE_TASKLET()注册tasklet函数
            在中断顶半部分，由tasklet_schedule()调度
        work queue:
            INIT_WORK()定义work queue处理函数
            在中断顶半部分，由schedule_work()调度工作队列执行
        softirq:
            这个接口一般是kernel自己使用的，用于内核子系统里面的处理，比如网络还有tasklet的处理，要用到这个。
            已知的软中断类型有：
            enum
            {
                HI_SOFTIRQ=0,    高优先级tasklet
                TIMER_SOFTIRQ,
                NET_TX_SOFTIRQ,
                NET_RX_SOFTIRQ,
                BLOCK_SOFTIRQ,
                BLOCK_IOPOLL_SOFTIRQ,
                TASKLET_SOFTIRQ,        普通优先级tasklet
                SCHED_SOFTIRQ,
                HRTIMER_SOFTIRQ,
                RCU_SOFTIRQ,    /* Preferable RCU should always be the last softirq */
                NR_SOFTIRQS
            };
            驱动的编写是不会直接用到这个softirq的。
            struct softirq_action{}    表示一个软中断处理函数
            open_softirq()        注册一个软中断。
            raise_softirq()        触发一个软中断，内部会wakeup_softirqd来真正唤起softirq的handler来处理。
            有关软中断到底执行在中断上下文还是进程上下文的问题：
            1.如果负载较轻，则执行在中断上下文。但注意，这个中断上下文，和真正的硬中断上下文有别，体现在内核的测试上下文的接口打印如下：
            in_interrupt: yes | in_irq: no | in_softirq: yes | in_serving_softirq: yes
            2.如果负载较重，则会调度ksoftirqd来帮忙，此时就是执行在进程上下文了。
            所以不能绝对的说softirq就一定是中断上下文。
        timer:
            由setup_timer和mod_timer这类API，使用的定时器中断，
            这个timer的回调函数，其实也是运行在中断上下文(TIMER_SOFTIRQ软中断)。
            所以同样不能timer的回调函数内部睡眠。

一些参数：（详见Linux\Kernel\学习资料\Interrupt Handling in Linux.pdf的解释）
</code></pre><ul>
<li>IRQF_SHARED - allow sharing the irq among several devices<br> 不同的驱动共用中断线的情况。<br> 只要所有用request_irq申请中断的实例，都是使用IRQF_SHARED标志，则request_irq针对同一个irq号，是可以重复申请的。<br> 至于可访问的全局地址，也就是那个void <em>dev_id的入参，用来保存驱动私有数据结构的指针，还是照常传入。<br> 中断到来的时候，会遍历所有共享此中断的isr，直到某个isr返回IRQ_HANDLED。在isr的上半部中，应该根据传入的</em>dev_id里面的信息，来判断是不是给自己的中断。<br> 如果不是，则返回IRQ_NONE来表示中断没有被处理。</li>
<li>IRQF_PROBE_SHARED - set by callers when they expect sharing mismatches to occur</li>
<li>IRQF_TIMER - Flag to mark this interrupt as timer interrupt</li>
<li>IRQF_PERCPU - Interrupt is per cpu</li>
<li>IRQF_NOBALANCING - Flag to exclude this interrupt from irq balancing</li>
<li>IRQF_IRQPOLL - Interrupt is used for polling (only the interrupt that is</li>
<li>registered first in an shared interrupt is considered for</li>
<li>performance reasons)</li>
<li>IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.        这个适合request_threaded_irq使用，如果thread_fn没执行完之前，不想要开中断，则用这个。</li>
<li>Used by threaded interrupts which need to keep the                比如说，中断会不断的来的情况（尤其是电平出发的中断）</li>
<li>irq line disabled until the threaded handler has been run.</li>
<li>IRQF_NO_SUSPEND - Do not disable this IRQ during suspend.  Does not guarantee</li>
<li>that this interrupt will wake the system from a suspended</li>
<li>state.  See Documentation/power/suspend-and-interrupts.txt        针对suspend,resume过程中，不可以被禁止的中断，用此标志（通常在suspend后期resume前期，irq会被禁止）</li>
<li>IRQF_FORCE_RESUME - Force enable it on resume even if IRQF_NO_SUSPEND is set</li>
<li>IRQF_NO_THREAD - Interrupt cannot be threaded</li>
<li>IRQF_EARLY_RESUME - Resume IRQ early during syscore instead of at device</li>
<li>resume time.</li>
<li>IRQF_COND_SUSPEND - If the IRQ is shared with a NO_SUSPEND user, execute this</li>
<li>interrupt handler after suspending interrupts. For system</li>
<li>wakeup devices users need to implement wakeup detection in</li>
<li>their interrupt handlers.<br>另，之前有个IRQF_DISABLED标志，但是已经过时了，现在不再使用了，即使置位，也什么都不做。（从2.6.36的内核开始）<br>2.6.35及以前版本的内核，支持中断的嵌套。所以有fast和slow两种中断。<br>fast中断就是屏蔽中断嵌套的。所以快。slow中断就是开着中断嵌套的，所以慢。<br>现在随着电脑速度的加快。后续的内核不再支持中断嵌套（软中断和硬中断都不支持嵌套）。所有的中断都是非嵌套的。要求中断快速的完成工作。如果有任何后续的工作，则放到线程里面去做。<br>所以2.6.36开始，IRQF_DISABLED标志就是空的标志，无作用。<br>那么对于真正不得已需要使用中断嵌套的场景。内核提供了local_irq_enable_in_hardirq();这个函数，来在中断里面开中断，从而使能嵌套。</li>
</ul>
<p>有关中断嵌套的进一步解释：<br>首先之前提到kernel是不支持中断嵌套的，在中断处理的上半部分，是关闭(mask)相应的中断响应的。<br>但这里注意两点：<br>1.不嵌套，是只对于单个CPU核，同一种中断，是不嵌套的。假设CPU A处理1号中断，这时候CPU B是可以同时被2号中断打断的。<br>2.对于单个CPU核A，被中断打断后，再来中断会怎样？（参考《ARM的中断处理 [二] - 知乎》）<br>针对ARM64的GIC中断控制器来分析。<br>第一个中断来了以后，这个中断是active状态，<br>假设正在中断上半部分的时候，来了第二个中断。<br>这时候linux设计了一种机制，就是让另外一个CPU B，去ack一下这个中断，并保存住这个pending信息(相当于软件琐存)，<br>这样该中断源又是Active状态了，CPU B也可以去干自己的事了。<br>CPU B在应答之后，还会让中断控制器屏蔽掉这个中断源，也就是告诉中断控制器，<br>我们CPU这边已经有pending的了，不再接受该中断源上新的中断了。<br>那么如果来了第三个中断，那么GIC还可以再从硬件层面琐存住这个中断的pending信息，然后再次进入A&amp;P状态。<br>所以理论上对于ARM64来说，其实即使不支持中断嵌套，针对同一个中断，最多可以三个中断排队处理而不会丢。<br>假如ARM64的GIC不支持锁存pending的中断，那linux也通过软件方式支持了两个中断排队。<br>当然第四个中断要是再来，那没辙了，只能丢弃。<br>所以，现在的kernel，对于smp的系统，其实中断来了以后，并不是马上就mask掉这个中断。而是等第二个中断pending以后，<br>才真的把中断给mask掉。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/12/tombstone/" rel="next" title="tombstone">
                <i class="fa fa-chevron-left"></i> tombstone
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/21/Kernel-API/" rel="prev" title="Kernel API">
                Kernel API <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Semiyd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">242</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">130</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semiyd</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
