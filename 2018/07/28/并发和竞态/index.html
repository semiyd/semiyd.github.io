<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="并发和竞态">
<meta property="og:type" content="article">
<meta property="og:title" content="并发和竞态">
<meta property="og:url" content="http://yoursite.com/2018/07/28/并发和竞态/index.html">
<meta property="og:site_name" content="Semiyd&#39;s Blog">
<meta property="og:description" content="并发和竞态">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-03-21T07:05:42.320Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并发和竞态">
<meta name="twitter:description" content="并发和竞态">






  <link rel="canonical" href="http://yoursite.com/2018/07/28/并发和竞态/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>并发和竞态 | Semiyd's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Semiyd's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/并发和竞态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Semiyd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Semiyd's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">并发和竞态
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-28 15:19:59" itemprop="dateCreated datePublished" datetime="2018-07-28T15:19:59+08:00">2018-07-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-03-21 15:05:42" itemprop="dateModified" datetime="2021-03-21T15:05:42+08:00">2021-03-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/" itemprop="url" rel="index"><span itemprop="name">Kernel</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/并发和竞态/" itemprop="url" rel="index"><span itemprop="name">并发和竞态</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><center><strong>并发和竞态</strong></center><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br></pre></td><td class="code"><pre><span class="line">==============================================并发和竞态===================================</span><br><span class="line">1.编译乱序</span><br><span class="line">	编译乱序是指，c代码的顺序正确，但编译的时候，编译器为了提高性能，会试图打乱顺序，编译出和实际c代码执行顺序不同的汇编代码。</span><br><span class="line">	内存屏障API</span><br><span class="line">	#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</span><br><span class="line">	#define mb() barrier()</span><br><span class="line">	#define rmb() mb()</span><br><span class="line">	#define wmb() mb()</span><br><span class="line">	从定义可以看出，以上所有的接口，其实就是一漂戏。内部就是同一句代码。</span><br><span class="line">	至于这句代码，是在c语言里面嵌入汇编的语句。具体的嵌入汇编涉及的语法，在下面的原子操作的部分，有详细的解释。</span><br><span class="line">		嵌入汇编的格式是：asm(code : output operand list : input operand list : clobber list)</span><br><span class="line">		简单来说，就是其实code，output operand list，input operand list都是空的。只有clobber list是memory。</span><br><span class="line">		这里的memory就是告知gcc，在汇编代码中，我修改了memory中的内容，嵌入式汇编之前的c代码块和嵌入式汇编之后的c代码块看到的memory是不一样的，</span><br><span class="line">		对memory的访问不能依赖于嵌入式汇编之前的c代码块中寄存器的内容，需要重新加载。 </span><br><span class="line"></span><br><span class="line">	例子1：</span><br><span class="line">	desc-&gt;word0 = address;</span><br><span class="line">	wmb();</span><br><span class="line">	desc-&gt;word1 = DESC_VALID;</span><br><span class="line">	这里的wmb的功能是，保证了屏障之前的写操作一定会在后来的写操作执行之前完成，不会编译乱序（例如硬件上需要先得到某个字节的更新，然后得到后面那个字节的更新）</span><br><span class="line">	类似的还有rmb，是指读操作。</span><br><span class="line">	mb指令保证了读写两者都不会</span><br><span class="line"></span><br><span class="line">	例子2：</span><br><span class="line">	以关抢占来保护临界区为例：</span><br><span class="line">	preempt_disable()</span><br><span class="line">	临界区 </span><br><span class="line">	preempt_enable()</span><br><span class="line">	所谓的preempt enable和disable其实就是对当前进程的struct thread_info中的preempt_count进行加一和减一的操作。具体的代码如下： </span><br><span class="line">	#define preempt_disable() \ </span><br><span class="line">	 do &#123; \ </span><br><span class="line">	     preempt_count_inc(); \ </span><br><span class="line">	     barrier(); \ </span><br><span class="line">	 &#125; while (0)  </span><br><span class="line">	注意到这里就用到了barrier()。barrier就象是c代码中的一个栅栏，将代码逻辑分成两段，barrier之前的代码和barrier之后的代码在经过编译器编译后顺序不能乱掉。</span><br><span class="line">	假设这里没有加barrier()，如果编译为了榨取CPU的performace而对汇编指令进行重排，那么临界区的代码就有可能位于preempt_count_inc之外，从而起不到保护作用。 </span><br><span class="line"></span><br><span class="line">	例子3：</span><br><span class="line">	当你的驱动调用printk的时候，实际上最终是通过console的write函数输出到了串口控制台。</span><br><span class="line">	这个console write的函数会包含下面的代码：</span><br><span class="line">	do &#123; </span><br><span class="line">	     获取TX FIFO状态寄存器 </span><br><span class="line">	    barrier(); </span><br><span class="line">	 &#125; while (TX FIFO没有ready); </span><br><span class="line">	写TX FIFO寄存器; </span><br><span class="line">	对于ARM来说，外设硬件的IO地址也被映射到了一段内存地址空间，对编译器而言，它并不知道这些地址空间是属于外设的。</span><br><span class="line">	如果没有barrier的话，编译的过程中，获取TX FIFO状态寄存器的指令可能和写TX FIFO寄存器指令进行重新排序，</span><br><span class="line">	在这种情况下，程序逻辑就不对了，因为我们必须要保证TX FIFO ready的情况下才能写TX FIFO寄存器。 </span><br><span class="line"></span><br><span class="line">	实际的定义位于：（4.4内核）</span><br><span class="line">	arch\arm\include\asm\barrier.h</span><br><span class="line">	实际的定义比上面的介绍要复杂些。针对不同的arm架构还有不同的内核配置，定义会有所不同。</span><br><span class="line"></span><br><span class="line">	memory barrier相关的API列表如下： </span><br><span class="line">		接口名称  	作用  </span><br><span class="line">		barrier()  		优化屏障，阻止编译器为了进行性能优化而进行的memory access reorder  </span><br><span class="line">		mb()  		内存屏障（包括读和写），用于SMP和UP  </span><br><span class="line">		rmb()  		读内存屏障，用于SMP和UP  </span><br><span class="line">		wmb()  		写内存屏障，用于SMP和UP  </span><br><span class="line">		smp_mb()  	用于SMP场合的内存屏障，对于UP不存在memory order的问题（对汇编指令），因此，在UP上就是一个优化屏障，确保汇编和c代码的memory order是一致的  </span><br><span class="line">		smp_rmb()  	用于SMP场合的读内存屏障  </span><br><span class="line">		smp_wmb()  	用于SMP场合的写内存屏障  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	有关读取寄存器的时候，防止乱序的问题</span><br><span class="line">		参考Documentation/io_ordering.txt</span><br><span class="line">		__iowmb()和__iormb()</span><br><span class="line">	类似mb()，只是这是针对io的mb()</span><br><span class="line">	读写寄存器的readl_relaxed()和readl()的区别就体现在有无__iormb()这块。</span><br><span class="line">	见arch\arm\include\asm\io.h		</span><br><span class="line">	#define readb(c)		(&#123; u8  __v = readb_relaxed(c); __iormb(); __v; &#125;)</span><br><span class="line">	#define readw(c)		(&#123; u16 __v = readw_relaxed(c); __iormb(); __v; &#125;)</span><br><span class="line">	#define readl(c)		(&#123; u32 __v = readl_relaxed(c); __iormb(); __v; &#125;)</span><br><span class="line"></span><br><span class="line">	#define writeb(v,c)		(&#123; __iowmb(); writeb_relaxed(v,c); &#125;)</span><br><span class="line">	#define writew(v,c)		(&#123; __iowmb(); writew_relaxed(v,c); &#125;)</span><br><span class="line">	#define writel(v,c)		(&#123; __iowmb(); writel_relaxed(v,c); &#125;)</span><br><span class="line"></span><br><span class="line">	#define readb_relaxed(c) (&#123; u8  __r = __raw_readb(c); __r; &#125;)</span><br><span class="line">	#define readw_relaxed(c) (&#123; u16 __r = le16_to_cpu((__force __le16) \</span><br><span class="line">					__raw_readw(c)); __r; &#125;)</span><br><span class="line">	#define readl_relaxed(c) (&#123; u32 __r = le32_to_cpu((__force __le32) \</span><br><span class="line">					__raw_readl(c)); __r; &#125;)</span><br><span class="line"></span><br><span class="line">	#define writeb_relaxed(v,c)	__raw_writeb(v,c)</span><br><span class="line">	#define writew_relaxed(v,c)	__raw_writew((__force u16) cpu_to_le16(v),c)</span><br><span class="line">	#define writel_relaxed(v,c)	__raw_writel((__force u32) cpu_to_le32(v),c)</span><br><span class="line"></span><br><span class="line">	总的来说。编译乱序就是指，因为编译器的原因。导致执行上的乱序。编译好以后，顺序就已经乱掉了。</span><br><span class="line"></span><br><span class="line">	barrier()这个函数，从cpu内部硬件上是如何实现的细节，参见“Linux内核同步机制之（三）：memory barrier.pdf”的2、cpu architecture和cache的组织 	这一段有详尽的解释，涉及cache操作的细节。</span><br><span class="line"></span><br><span class="line">2.指令乱序</span><br><span class="line">	指令乱序是指，编译成汇编机器码以后，就算没有乱序，在执行的时候，cpu会根据实际情况决定是否乱序执行。</span><br><span class="line">	下面就单核和多核两种不同的情形，针对执行顺序的优化进行介绍：</span><br><span class="line">	单核：</span><br><span class="line">		考虑下面的例子：</span><br><span class="line">		LDR	r0,	[r1];</span><br><span class="line">		STR	r2,	[r3];</span><br><span class="line">		假设LDR的时候，指令缓存未命中。这时候，指令缓存就会去做填充行的动作，并且需要比较多个时钟周期。</span><br><span class="line">		armv5及以前的处理器，会等待这一过程完毕，然后再去执行STR。</span><br><span class="line">		armv6及以后的处理器，会识别出，下一条指令STR，并不依赖上一条执行LDR的结果（这种情况称为未遇到”依赖点“）。从而安排STR执行提前执行。</span><br><span class="line">		如此就产生了一个指令的乱序。</span><br><span class="line">		对于单核的情况，程序员无需关心这一细节。因为这种指令乱序，在单核cpu上发生的时候，如果没遇到依赖点，则会乱序。如果遇到依赖点，则会等待。</span><br><span class="line">		所以说，对程序员来说，这种单核的乱序是不可见的。</span><br><span class="line">	多核：</span><br><span class="line">		刚刚说了单核的指令乱序。对于遇到依赖点的情况，在单核上，cpu会自动等待。</span><br><span class="line">		但如果依赖点变成，如果一个核cpu1，去依赖了cpu0的某个执行结果呢？</span><br><span class="line">		问题就在于，这种跨越核的依赖，默认cpu1是看不到cpu0的情况的，也就是说cpu1并不知道自己其实依赖着cpu0的某个步骤。</span><br><span class="line">		考虑下面这个具体的例子：</span><br><span class="line">		core 0 					core 1 </span><br><span class="line">		Write A;					Load B;</span><br><span class="line">		Write B;					Load A; </span><br><span class="line"> 		假设core 0，write A的时候，发生Cache Miss，所以会直接去先执行write B。那么就会导致在cache中 A的最新值更新慢于B的最新值。</span><br><span class="line">		于是在core1中的指令Load B就会拿到新值，而Load A 就会拿到旧值。</span><br><span class="line">		如果A与B有相互关系的话，便可能产生死锁等问题。</span><br><span class="line">		解决办法是：</span><br><span class="line">		core 0 					core 1 </span><br><span class="line">		Write A;					Load B;</span><br><span class="line">		DMB;					Load A; </span><br><span class="line">		Write B;	</span><br><span class="line">		DMB的作用：DMB前面的LOAD/STORE读写的最新值的acknowledgement在时间上一定先于DMB之后的指令。总之就是DMB之前的指令，肯定会等待完成。</span><br><span class="line">		这种汇编级别支持的硬件指令，一共有下面三种：</span><br><span class="line">		DMB,DSB,ISB</span><br><span class="line">		Data Memory Barrier(DMB) </span><br><span class="line">		Data Synchronization Barrier(DSB) </span><br><span class="line">		Instruction Synchronization Barrier(ISB) </span><br><span class="line">		DSB 和DMB容易混淆。他们的区别在于：DMB可以继续执行之后的指令，只要这条指令不是内存访问指令。而DSB不管它后面的什么指令，都会强迫CPU等待它之前的指令执行完毕。</span><br><span class="line">		其实在很多处理器设计的时候，DMB和DSB没有区别（DMB完成和DSB同样的功能）。</span><br><span class="line">		ISB不仅做了DSB所做的事情，还将流水线清空。于是他们的重量级排序可以是：ISB&gt;DSB&gt;DMB</span><br><span class="line">	以上内容详见内核的Documentation/memory-barriers.txt</span><br><span class="line">	</span><br><span class="line">3.临界区：</span><br><span class="line">	临界区就是进程之间可能会发生冲突的数据区域。</span><br><span class="line">	进程之间，其实数据地址空间，是独立的。</span><br><span class="line">	所以理论上，其实仅仅是用户空间的话，进程之间，不存在临界区。</span><br><span class="line">	临界区在哪？</span><br><span class="line">		临界区一定位于内核空间。要么是内核的数据结构，要么是某种硬件寄存器资源。</span><br><span class="line">	那么其实针对临界区的一些加锁的保护，都是内核的API。进程是没法直接调用的。所以使用锁的API，要不是内核代码，要不是内核驱动。</span><br><span class="line">		那么进程，是通过系统调用，来真正调用这些内核的代码的。</span><br><span class="line">		所以如果涉及临界区，加锁，解锁，其实一定涉及系统调用。</span><br><span class="line">	只有进程通过系统调用，进入内核空间，才可能去访问临界区。</span><br><span class="line">	而抢占是什么？抢占说白了，就是不等一个进程的系统调用（内核态）完成，就去做另外一个高优先级进程的事情（用户态）。对于临界区的访问，如果这时候不加以保护，就会发生冲突。</span><br><span class="line">	换句话说，对于单核cpu，只要禁掉抢占，就可以保证，在不同优先级的用户进程之间，就不会有临界区发生冲突的问题。（见下面有关spinlock单核的情况）</span><br><span class="line">	但这里仅仅是指在不同优先级的用户进程之间，能这样关抢占来保护。在单核的不同的内核线程之间（例如数个同时运行的workqueue），则spinlock起不到保护临界区的作用。（见下面有关spinlock的介绍）</span><br><span class="line">	对于多核cpu，则禁掉本地的抢占，并不能直接阻止别的核上的程序，通过系统调用来访问临界区，还需要进一步的保护（比如说让别的核 死等，详见下面有关spinlock多核的情况解释）</span><br><span class="line">	</span><br><span class="line">4.屏蔽中断以避免一部分竞态的情形</span><br><span class="line">	local_irq_disable()</span><br><span class="line">	...</span><br><span class="line">	critical section</span><br><span class="line">	...</span><br><span class="line">	local_irq_enable()</span><br><span class="line">	以上这种做法，可以防止中断处理程序和进程之间的并发。并且因为内核的进程调度是依赖中断的。所以保护区内，进程调度被禁止，进程之间的并发也可以避免(但针对这种情况，代价太大，不如用spinlock)。</span><br><span class="line">	local_irq_disable()的原理，是屏蔽ARM处理器CPSR处理器的I位。</span><br><span class="line">	见arch\arm\include\asm\irqflags.h</span><br><span class="line">	static inline void arch_local_irq_disable(void)</span><br><span class="line">	&#123;</span><br><span class="line">		asm volatile(</span><br><span class="line">			&quot;	cpsid i			@ arch_local_irq_disable&quot;</span><br><span class="line">			:</span><br><span class="line">			:</span><br><span class="line">			: &quot;memory&quot;, &quot;cc&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	但是，这种屏蔽中断来获得安全临界区的方法，有两个问题：</span><br><span class="line">	a.Linux的异步I/O，进程调度等很多操作都依赖中断。长期屏蔽中断的话，会导致数据丢失甚至系统崩溃。所以临界区里面的操作必须快。</span><br><span class="line">	b.这个方法针对多核SMP的情况无效。只能屏蔽本cpu核的中断，无法解决SMP情况下的竞态问题。</span><br><span class="line"></span><br><span class="line">5.锁机制：</span><br><span class="line">	原子操作</span><br><span class="line">		所谓原子操作，就是指内核提供了一系列的API，来完成一些特定的操作，比如把某个变量加减，然后再判断值是否等于0.</span><br><span class="line">		你只要使用这些API，如果能运行成功，就能保证整个操作是原子的。如果真的被以外打断，那也不会破坏数据，只会返回操作失败。</span><br><span class="line">		实现的原理：</span><br><span class="line">			ARMv6及其之前，不支持SMP，都是通过关闭中断来完成的。</span><br><span class="line">				static inline int atomic_add_return(int i, atomic_t *v) </span><br><span class="line">				 &#123; </span><br><span class="line">				     unsigned long flags; </span><br><span class="line"> 				    int val; </span><br><span class="line"></span><br><span class="line">				    raw_local_irq_save(flags); </span><br><span class="line">				     val = v-&gt;counter; </span><br><span class="line">				     v-&gt;counter = val += i; </span><br><span class="line">				     raw_local_irq_restore(flags); </span><br><span class="line"></span><br><span class="line">				    return val; </span><br><span class="line">				 &#125; </span><br><span class="line">			ARMv6之后：</span><br><span class="line">				/*</span><br><span class="line">				 * ARMv6 UP and SMP safe atomic ops.  We use load exclusive and</span><br><span class="line">				 * store exclusive to ensure that these are atomic.  We may loop</span><br><span class="line">				 * to ensure that the update happens.</span><br><span class="line">				 */</span><br><span class="line">				static inline void atomic_add(int i, atomic_t *v)</span><br><span class="line">				&#123;</span><br><span class="line">					unsigned long tmp;</span><br><span class="line">					int result;</span><br><span class="line"></span><br><span class="line">					__asm__ __volatile__(&quot;@ atomic_add\n&quot;</span><br><span class="line">				&quot;1:	ldrex	%0, [%3]\n&quot;</span><br><span class="line">				&quot;	add	%0, %0, %4\n&quot;</span><br><span class="line">				&quot;	strex	%1, %0, [%3]\n&quot;</span><br><span class="line">				&quot;	teq	%1, #0\n&quot;</span><br><span class="line">				&quot;	bne	1b&quot;</span><br><span class="line">					: &quot;=&amp;r&quot; (result), &quot;=&amp;r&quot; (tmp), &quot;+Qo&quot; (v-&gt;counter)</span><br><span class="line">					: &quot;r&quot; (&amp;v-&gt;counter), &quot;Ir&quot; (i)</span><br><span class="line">					: &quot;cc&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				为了说明上一段代码的内容，先说下c语言里面嵌入汇编的写法：</span><br><span class="line">				原始的格式是：</span><br><span class="line">				asm(code : output operand list : input operand list : clobber list)</span><br><span class="line">				asm是GNU的扩展。__asm__也是GNU的扩展，作用一样。</span><br><span class="line">				这里的__volatile__主要是用来防止编译器优化的。如果你的嵌入式汇编使用__asm__ __volatile__(嵌入式汇编)的语法格式，</span><br><span class="line">				那么也就是告诉编译器，不要随便动我的嵌入汇编代码。</span><br><span class="line">				那么，上面这种嵌入汇编的格式，解释如下：</span><br><span class="line">				1.分为code : output operand list : input operand list : clobber list四部分。每个部分用引号:来分开。</span><br><span class="line">				2.code就是汇编代码的主体，每一行用&quot;&quot;双引号包起来，结尾用\n表示换行。</span><br><span class="line">				3.output operand list是刚刚的code会修改的变量，中间用逗号,隔开。</span><br><span class="line">				4.input operand list是刚刚的code会读取的入参，中间用逗号,隔开。</span><br><span class="line">				5.clobber list是除了output operand list以外，code部分还会修改到的寄存器/变量等，需要通知gcc，否则会影响后续c语言的正常执行。</span><br><span class="line">				那么，在code里面，可以看到很多%0 %1这样的符号。这个其实是代指output operand list和input operand list里面的变量的编号。</span><br><span class="line">				编号规则是这样的。</span><br><span class="line">				因为是output operand在前，input operand在后。</span><br><span class="line">				那么按照变量出现的次序，依次从%0开始编号。以上面的代码为例：</span><br><span class="line">				(result),(tmp)，(v-&gt;counter)，(&amp;v-&gt;counter)，(i)分别对应：</span><br><span class="line">				%0,%1,%2,%3,%4，并出现在code中。</span><br><span class="line">				对于output operand list，必须符合这个格式：[ [asmSymbolicName] ] constraint (cvariablename)</span><br><span class="line">					asmSymbolicName就是个代称。将来可以在code里面去使用，假设名字叫[aaa]，那么code里面，就可以%[aaa]这样来引用。</span><br><span class="line">					如果asmSymbolicName没有定义，则将采用上面说到的，直接%0这样用序号来引用。例如上面的atomic_add就没有定义asmSymbolicName。</span><br><span class="line">					contraint需要以=号或者+号开始。=号表示仅仅会写，不会去读，+号表示会读和写（具体含义不理解）</span><br><span class="line">					在=号或者+号之后，r表示变量在寄存器里，m表示变量在内存里。	rm可以组合，表示交由编译器决定最优的方案。</span><br><span class="line">					r的意思就是告诉编译器，帮我选择一个通用寄存器保存该操作数吧。</span><br><span class="line">					另外，&amp;也是constraint，表示告诉GCC，不要把输出变量，去覆盖掉之前放输入值的寄存器。</span><br><span class="line">						具体原因是。GCC有时候，会认为，输入值，读了以后，就没用了。此时处于优化的原因，可以在函数执行完以后，把输出的值，放在原来</span><br><span class="line">						存放输入值的寄存器Rn里面。</span><br><span class="line">				对于input operand list，必须符合这个格式：[ [asmSymbolicName] ] constraint (cexpression)</span><br><span class="line">					asmSymbolicName同output operand list里面的定义。</span><br><span class="line">					constraint 和输出不同，不以=或者+号开头。r表示变量在寄存器里，m表示变量在内存里。rm可以组合，表示交由编译器决定最优的方案。</span><br><span class="line">					&quot;Ir&quot; (i)，这里“I”这个限制符对应ARM平台，表示这是一个有特定限制的立即数，</span><br><span class="line">						该数必须是0～255之间的一个整数通过rotation的操作得到的一个32bit的立即数。</span><br><span class="line">						对于ARM来说，每个指令32个bit，其中12个bit被用来表示立即数，其中8个bit是真正的数据，4个bit用来表示如何rotation。</span><br><span class="line">				对于clobber list</span><br><span class="line">					clober list是gcc和gas的接口，用于gas通知gcc它对寄存器和memory的修改情况。</span><br><span class="line">					一般都填cc。通知gcc，嵌入式汇编代码更新了condition code register。 </span><br><span class="line">				所以</span><br><span class="line">				注意：</span><br><span class="line">					不要尝试在不使用input operand list的情况下，在汇编里面去访问比如c语言的全局变量。</span><br><span class="line">				现在回到主题也就是ldrex和strex</span><br><span class="line">				ldr和str这两条指令大家都是非常的熟悉了，后缀的ex表示Exclusive，是ARMv7提供的为了实现同步的汇编指令。 </span><br><span class="line">				LDREX  &lt;Rt&gt;, [&lt;Rn&gt;]	也就是读取操作</span><br><span class="line">					&lt;Rn&gt;是base register，保存memory的address，LDREX指令从base register中获取memory address，</span><br><span class="line">					且将memory的内容加载到&lt;Rt&gt;(destination register)中</span><br><span class="line">					这些操作和ldr的操作是一样的，那么如何体现exclusive呢？</span><br><span class="line">					其实，在执行这条指令的时候，还放出两条“狗”来负责观察特定地址的访问（就是保存在[&lt;Rn&gt;]中的地址了）</span><br><span class="line">					这两条狗一条叫做local monitor，一条叫做global monitor。</span><br><span class="line">				STREX &lt;Rd&gt;, &lt;Rt&gt;, [&lt;Rn&gt;]	也就是写入操作</span><br><span class="line">					和LDREX指令类似，&lt;Rn&gt;是base register，保存memory的address，STREX指令从base register中获取memory address，</span><br><span class="line">					并且将&lt;Rt&gt; (source register)中的内容加载到该memory中。</span><br><span class="line">					这里的&lt;Rd&gt;保存了memeory 更新成功或者失败的结果，0表示memory更新成功，1表示失败。</span><br><span class="line">					STREX指令是否能成功执行是和local monitor和global monitor的状态相关的。</span><br><span class="line">					对于Non-shareable memory（该memory不是多个CPU之间共享的，只会被一个CPU访问），只需要放出该CPU的local monitor这条狗就OK了</span><br><span class="line">					下面的表格可以描述这种情况 </span><br><span class="line">					thread 1  	thread 2  	local monitor的状态  </span><br><span class="line">      									Open Access state  </span><br><span class="line">					LDREX     			Exclusive Access state  </span><br><span class="line">   							LDREX  		Exclusive Access state  </span><br><span class="line">   							Modify  		Exclusive Access state  </span><br><span class="line">   							STREX  		Open Access state  </span><br><span class="line">					Modify     			Open Access state  </span><br><span class="line">					STREX     			在Open Access state的状态下，执行STREX指令会导致该指令执行失败  </span><br><span class="line">      									保持Open Access state，直到下一个LDREX指令  </span><br><span class="line">				这个表格表示的情况是这样的。假设有一个thread1。他的本意是对某个数据进行更改。使用了原子操作。</span><br><span class="line">				那么，在thread1用LDREX获取数据后（写之前肯定要先读出来），这时候突然因为某种原因，被thread2打断了。</span><br><span class="line">				thread2一下子完成了LDREX，修改，STREX这一系列读然后写入的操作。	</span><br><span class="line">				这时候，标志位local monitor因为thread2的STREX的执行，被置为Open Access state  </span><br><span class="line">				此时thread1才有机会修改并STREX。但是在Open Access state的状态下，执行STREX指令会导致该指令执行失败 。</span><br><span class="line">				原因是，STREX执行的时候，如果之前没被打断，肯定应该还在Exclusive Access state</span><br><span class="line">				但此时既然是Open Access state，就意味着有别人（thread2）对刚刚的数据进行了修改。</span><br><span class="line">				这时候如果thread1的STREX继续执行，会导致冲掉thread2的写入的数据.</span><br><span class="line">				所以这个时候thread1的原子操作就会失败返回。保证了操作的原子性。</span><br><span class="line">				那么结合atomic_add的真实代码。可以看到，如果失败，就bne 1b，也就是跳转到标签1处，也就是重新开始一次新的写入的尝试。</span><br><span class="line"></span><br><span class="line">				说白了就是。真正写入数据，是由STREX执行的。而不是普通的Store指令。这个指令很特殊，不符合原子操作的条件下，是没法写成功的。</span><br><span class="line"></span><br><span class="line">				另外，对于shareable memory，需要系统中所有的local monitor和global monitor共同工作，完成exclusive access，概念类似，这里就不再赘述了。 </span><br><span class="line"></span><br><span class="line">		主要用于实现资源计数</span><br><span class="line">		atomic_set(),atomic_inc(),atomic_dec()</span><br><span class="line">		原子操作运用的实例：</span><br><span class="line">		static atomic_t xxx_available = ATOMIC_INIT(1);	定义原子变量，并初始化为1.</span><br><span class="line">		static int xxx_open(...)		设备的open()函数的定义</span><br><span class="line">			&#123;</span><br><span class="line">				if(!atomic_dec_and_test(&amp;xxx_available))	&#123;	把原子量（初始值为1）减一，然后如果是0，则返回1，如果是非0，则返回0.</span><br><span class="line">					atomic_inc(&amp;xxx_available);			所以如果设备已经有人打开，这时候再atomic_dec_and_test，原子量是-1，所以需要恢复原子量的值</span><br><span class="line">					return -EBUSY;				也就是atomic_inc再加回去，然后返回错误，因为这意味着设备已经被打开了。</span><br><span class="line">					&#125;</span><br><span class="line">				...	做具体的open设备的操作</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		static int xxx_close(...)		设备的close()函数的定义</span><br><span class="line">			&#123;</span><br><span class="line">				atomic_inc(&amp;xxx_available);				设备关闭，原子量可以恢复成1了。（相当于资源计数）</span><br><span class="line">				return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		以上的例子，说明了两点。一就是原子量通常的作用，也就是资源计数。二是，在对原子量操作的过程中，是安全的，不用特别的保护，只需使用atomic_xxx的API，就可以保证原子操作。</span><br><span class="line"></span><br><span class="line">		代码位置：</span><br><span class="line">			arch\arm\include\asm\atomic.h</span><br><span class="line">	自旋锁								-用于中断/进程上下文</span><br><span class="line">		计划：</span><br><span class="line">			看http://www.wowotech.net/kernel_synchronization/spinlock.html</span><br><span class="line">			看书</span><br><span class="line"></span><br><span class="line">		几个特点：</span><br><span class="line">		spinlock是一种死等的锁机制。也就是说，某个进程尝试获取spinlock失败时，会不停的尝试获取锁。</span><br><span class="line">		spinlock和信号量不同，信号量可以允许多于一个的锁持有者进入临界区。spinlock只允许一个锁持有者进入临界区</span><br><span class="line">		spinlock适合临界区代码很短的情形。否则临界区代码太长，会导致别的申请获得锁的进程一直在死等，浪费cpu资源。</span><br><span class="line">			（ARM提供了WFE和SEV这样的类似指令，避免CPU进入busy loop的悲惨境地，后面会介绍）</span><br><span class="line">		spinlock可以在中断里面运行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		spinlock获取锁期间，当前cpu，内核会禁掉抢占。原因是：</span><br><span class="line">			之前介绍临界区的概念的时候，其实已经说明了为什么要这样做。</span><br><span class="line">			对于spinlock，其实要分UP和SMP两种情况讨论的。</span><br><span class="line">			UP:</span><br><span class="line">				对于UP，其实spinlock加锁的过程，就是关掉抢占。并没必要去死等，也没有死等的代码实现。</span><br><span class="line">				如果不关掉抢占，就没法保证对临界区的保护了。因为随时会被别的高优先级进程打断，高优先级进程再进系统调用，就可能访问需要保护的临界区。</span><br><span class="line">				如果UP，内核又不支持抢占的情况，自然不用关闭抢占了。所以spinlock()会退化成空操作。</span><br><span class="line">					当然这时候如果涉及中断里面访问临界区的情况，还是要关中断的。如spin_lock_irqsave()。	</span><br><span class="line">				总结下来，就是对于单核的情况，其实spinlock并不会真的导致cpu忙等待。</span><br><span class="line">			SMP:</span><br><span class="line">				对于多核。其实除了UP的关抢占，还需要进一步的操作，让别的核的CPU死等（WFE和SEV），才能真正实现对临界区的保护。</span><br><span class="line"></span><br><span class="line">		另外，如果需要在中断里面获取spinlock，又在进程里面要用spinlock。则进程里面的spinlock需要和禁止本cpu中断的API一起组合使用（如spin_lock_irqsave()）。原因是：</span><br><span class="line">			假设某个进程持有了spinlock在访问临界资源。	</span><br><span class="line">			这个时候本cpu来了个中断。中断里面也需要访问临界资源。</span><br><span class="line">			但因为spinlock已被进程持有。导致中断里面一直在死等自旋。又因为出不了中断，导致进程的spinlock无法释放。造成死锁。</span><br><span class="line">			当然其实如果是多核的情况，非本地cpu发生中断，是没关系的。因为非本地的cpu，会在非本地的cpu中断里面自旋，但并不妨碍本地cpu把临界区访问完，然后释放spinlock。</span><br><span class="line">			再多说一句，就是如果是在中断的底半部分使用spinlock。那其实只用禁止底半部分中断就可以了。</span><br><span class="line">			另外，这种中断和进程同时访问临界区的情形。为了安全起见，中断里面是要用spinlock()函数的。</span><br><span class="line">				如果是UP。那么假设正常情况下，进程里面已经用了spin_lock_irqsave()。意味着进程访问临界区的时候，其实没有中断可以进来打断。</span><br><span class="line">					中断又不能嵌套，所以没关系，中断里面可以不用spinlock()函数.</span><br><span class="line">				如果是SMP，即使进程里面已经用了spin_lock_irqsave()，也不能阻止非本地的cpu核进中断。这时候就要求非本地的cpu核在中断里面自旋一会。</span><br><span class="line">					所以中断里面必须spinlock()函数.</span><br><span class="line">				所以总体来说，为了兼容性起见，驱动里面的中断，还是加上spinlock()函数为好。即使目前暂时是跑在UP平台上的。</span><br><span class="line">		</span><br><span class="line">		中断之间竞争spinlock的情形分析：</span><br><span class="line">			1.硬件中断之间进行竞争</span><br><span class="line">				假设有两种不同的硬件中断。都需要访问同一个临界资源。</span><br><span class="line">				因为2.6.35以后的新内核，中断是没有嵌套的。所以中断处理过程中，内核本身就是关中断的。所以涉及在中断里面获取spinlock的时候，并不需要特别去关闭中断。</span><br><span class="line">				总之就是这种情况，什么都不用做。这个是针对UP。</span><br><span class="line">				针对SMP，还是加个spinlock()吧。</span><br><span class="line">			2.底半部分之softirq</span><br><span class="line">				假设只有一种softirq要访问临界资源。</span><br><span class="line">				同一个softirq，会到不同的cpu核上运行。支持并发，也就是可以重入。</span><br><span class="line">				这时候，即使是只有一种softirq要访问临界资源，对于多核cpu的情况，也需要加spinlock保护下。</span><br><span class="line">				而且，softirq其实是中断上下文。所以和上面的“硬件中断之间进行竞争”原因一样，不用特别去关闭中断。</span><br><span class="line">			3.底半部分之tasklet之间</span><br><span class="line">				假设只有一种tasklet要访问临界资源。</span><br><span class="line">				同一个tasklet，并不能在不同的cpu核上并发，也不会在同一个cpu上并发。（也就是不支持重入）</span><br><span class="line">				所以如果是临界资源的访问仅存在于tasklet。则无需加spinlock。因为tasklet本身是不会并发的。（当然如果进程中还要访问临界资源，那肯定就要加spinlock了）</span><br><span class="line">				再多说一句。如果共享资源只在两个或者多个tasklet/timer上访问。则无需使用spin_lock_bh。原因同样是因为tasklet/timer不会在同一个cpu上并发。</span><br><span class="line"></span><br><span class="line">		内核线程之间，竞争spinlock的情形分析：</span><br><span class="line">			详见最后面的实践部分。</span><br><span class="line">			对于UP，那么之前讲了，spinlock退化成关抢占。但是内核线程之间，不存在抢占的问题。（抢占是针对不同的优先级的用户进程之间而言的。）</span><br><span class="line">				所以UP上，如果开了数个内核线程，比如数个work queque，这些work queue都会访问同一个临界区的话。</span><br><span class="line">				那么用spinlock来保护是没用的。这时候只能用semaphore。</span><br><span class="line">			对于SMP，可以正常用spinlock进行保护，因为获取不到锁的核会进入WFE。</span><br><span class="line"></span><br><span class="line">		代码的实现：</span><br><span class="line">			体系无关的部分代码：</span><br><span class="line">				include/linux/spinlock_types.h	</span><br><span class="line">					这个头文件定义了通用spin lock的基本的数据结构（例如spinlock_t）和如何初始化的接口（DEFINE_SPINLOCK）。</span><br><span class="line">					这里的“通用”是指不论SMP还是UP都通用的那些定义。</span><br><span class="line">				include/linux/spinlock_types_up.h</span><br><span class="line">					这个头文件不应该直接include，在include/linux/spinlock_types.h文件会根据系统的配置（是否SMP）include相关的头文件，</span><br><span class="line">					如果UP则会include该头文件。</span><br><span class="line">					这个头文定义UP系统中和spin lock的基本的数据结构和如何初始化的接口。</span><br><span class="line">				include/linux/spinlock.h</span><br><span class="line">					这个头文件定义了通用spin lock的接口函数声明，例如spin_lock、spin_unlock等，使用spin lock模块接口API的驱动模块或者其他内核模块都需要include这个头文件。 </span><br><span class="line">				include/linux/spinlock_up.h</span><br><span class="line">					这个头文件不应该直接include，在include/linux/spinlock.h文件会根据系统的配置（是否SMP）include相关的头文件。这个头文件是debug版本的spin lock需要的。 </span><br><span class="line">				include/linux/spinlock_api_up.h</span><br><span class="line">					同上，只不过这个头文件是non-debug版本的spin lock需要的 </span><br><span class="line">				linux/spinlock_api_smp.h</span><br><span class="line">					SMP上的spin lock模块的接口声明 </span><br><span class="line">				kernel/locking/spinlock.c</span><br><span class="line">					SMP上的spin lock实现。 </span><br><span class="line">				这块的代码结构是很凌乱的。而且分UP还是SMP，debug还是non-debug。我觉得作为内核使用者来说，稍作了解即可。</span><br><span class="line">				稍作整理如下：（摘自include/linux/spinlock.h的注释部分）</span><br><span class="line">				UP需要的头文件  			SMP需要的头文件  </span><br><span class="line">				linux/spinlock_type_up.h: 		asm/spinlock_types.h </span><br><span class="line">				linux/spinlock_types.h: 		linux/spinlock_types.h: </span><br><span class="line"> 				linux/spinlock_up.h: 		asm/spinlock.h </span><br><span class="line"> 				linux/spinlock_api_up.h: 		linux/spinlock_api_smp.h:</span><br><span class="line"> 				linux/spinlock.h 			linux/spinlock.h </span><br><span class="line"> </span><br><span class="line">				数据结构：</span><br><span class="line">					一个spinlock_t的数据类型，其本质上是一个整数值（对该数值的操作需要保证原子性），该数值表示spin lock是否可用。</span><br><span class="line">					初始化的时候被设定为1。当thread想要持有锁的时候调用spin_lock函数，该函数将spin lock那个整数值减去1，然后进行判断，如果等于0，</span><br><span class="line">					表示可以获取spin lock，如果是负数，则说明其他thread的持有该锁，本thread需要spin。 </span><br><span class="line">					内核中的spinlock_t的定义如下：</span><br><span class="line">					typedef struct spinlock &#123;</span><br><span class="line">						union &#123;</span><br><span class="line">							struct raw_spinlock rlock;</span><br><span class="line">						&#125;;</span><br><span class="line">					&#125; spinlock_t;</span><br><span class="line">					那么struct raw_spinlock的定义如下：</span><br><span class="line">					typedef struct raw_spinlock &#123;</span><br><span class="line">						arch_spinlock_t raw_lock;</span><br><span class="line">					&#125; raw_spinlock_t;</span><br><span class="line">					这个arch_spinlock_t，是和平台相关的定义。下面会解释。</span><br><span class="line"></span><br><span class="line">				API接口：</span><br><span class="line">					接口API的类型  					spinlock中的定义  		raw_spinlock的定义  </span><br><span class="line"></span><br><span class="line">					定义spin lock并初始化  				DEFINE_SPINLOCK  	DEFINE_RAW_SPINLOCK  </span><br><span class="line">					动态初始化spin lock  				spin_lock_init  		raw_spin_lock_init  </span><br><span class="line">					获取指定的spin lock  				spin_lock  		raw_spin_lock  </span><br><span class="line">					获取指定的spin lock同时disable本CPU中断  		spin_lock_irq  		raw_spin_lock_irq  </span><br><span class="line">					保存本CPU当前的irq状态， 	 			spin_lock_irqsave  		raw_spin_lock_irqsave  </span><br><span class="line">					      disable本CPU中断并获取指定的spin lock</span><br><span class="line">					获取指定的spin lock同时disable本CPU的bottom half  	spin_lock_bh  		raw_spin_lock_bh  	用于timer/tasklet里面涉及获取锁</span><br><span class="line">					释放指定的spin lock  				spin_unlock  		raw_spin_unlock  </span><br><span class="line">					释放指定的spin lock同时enable本CPU中断  		spin_unlock_irq  		raw_spin_unock_irq  </span><br><span class="line">					释放指定的spin lock同时恢复本CPU的中断状态  		spin_unlock_irqstore  	raw_spin_unlock_irqstore  </span><br><span class="line">					获取指定的spin lock同时enable本CPU的bottom half  	spin_unlock_bh  		raw_spin_unlock_bh  </span><br><span class="line">					尝试去获取spin lock，如果失败</span><br><span class="line">					      不会spin，而是返回非零值			spin_trylock  		raw_spin_trylock  </span><br><span class="line">					判断spin lock是否是locked，如果其他的thread已经	spin_is_locked  		raw_spin_is_locked  </span><br><span class="line">						获取了该lock，那么返回非零值，否则返回0  </span><br><span class="line"></span><br><span class="line">				以spin_lock()的代码，来看下里面如何实现的：</span><br><span class="line">					static inline void spin_lock(spinlock_t *lock)</span><br><span class="line">					&#123;</span><br><span class="line">						raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">					&#125;</span><br><span class="line">					那么：</span><br><span class="line">					#define raw_spin_lock(lock)	_raw_spin_lock(lock)</span><br><span class="line">					那么：_raw_spin_lock()的定义，其实根据UP还是SMP，是不一样的。</span><br><span class="line">					UP:（在spinlock_api_up.h）</span><br><span class="line">						#define _raw_read_lock(lock)			__LOCK(lock)	</span><br><span class="line">						#define __LOCK(lock) \</span><br><span class="line">						  do &#123; preempt_disable(); __acquire(lock); (void)(lock); &#125; while (0)</span><br><span class="line">						# define __acquire(x) (void)0</span><br><span class="line">						在UP单核的情况下，spinlock仅仅是关闭的抢占，就足以保护临界区。具体原因上面的段落已经解释过了。</span><br><span class="line">					SMP:（在spinlock_api_smp.h）</span><br><span class="line">						#define _raw_spin_lock(lock) __raw_spin_lock(lock)</span><br><span class="line">						static inline void __raw_spin_lock(raw_spinlock_t *lock)</span><br><span class="line">						&#123;</span><br><span class="line">							preempt_disable();</span><br><span class="line">							spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">							LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">						&#125;</span><br><span class="line">						在SMP的情况下。当然首先是关抢占，解决本地cpu的冲突。	</span><br><span class="line">						那么在这个基础上，还要做这么两件事情：</span><br><span class="line">						spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);</span><br><span class="line">							spin_acquire可以略过，这是和运行时检查锁的有效性有关的，如果没有定义CONFIG_LOCKDEP其实就是空函数。</span><br><span class="line">						LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock); </span><br><span class="line">							LOCK_CONTENDED就是核心所在了。</span><br><span class="line">							#define LOCK_CONTENDED(_lock, try, lock) \</span><br><span class="line">								lock(_lock)</span><br><span class="line">							也就是执行do_raw_spin_lock()</span><br><span class="line">							static inline void do_raw_spin_lock(raw_spinlock_t *lock) __acquires(lock)</span><br><span class="line">							&#123;</span><br><span class="line">								__acquire(lock);</span><br><span class="line">								arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">							&#125;</span><br><span class="line">							__acquire()和静态代码检查有关，无视。</span><br><span class="line">							可以看到，这里涉及的arch_spin_lock()，就到了真正和架构相关的部分了。下面来介绍。</span><br><span class="line">			体系架构相关的部分代码：</span><br><span class="line">				arch/arm/include/asm/spinlock.h</span><br><span class="line">					定义了具体ARM架构上，spinlock相关API的具体实现。</span><br><span class="line">				arch/arm/include/asm/spinlock_type.h</span><br><span class="line">					定义了arch_spinlock_t结构体</span><br><span class="line">				重点就是arch_spin_lock()的实现。</span><br><span class="line">				因为存在历史沿革问题，体系相关代码的分析，需要分为老内核和新内核两部分来解释。</span><br><span class="line">				老内核：（2.6.23前后，简要介绍。重点介绍新内核的细节）</span><br><span class="line">					2.6.23内核里的定义：</span><br><span class="line">					typedef struct &#123;</span><br><span class="line">						volatile unsigned int lock;</span><br><span class="line">					&#125; raw_spinlock_t;//那时候还是使用raw_spinlock_t而不是arch_spinlock_t</span><br><span class="line">					2.6.39的内核里的定义：</span><br><span class="line">					typedef struct &#123;</span><br><span class="line">						volatile unsigned int lock;</span><br><span class="line">					&#125; arch_spinlock_t;</span><br><span class="line">					都差不多。</span><br><span class="line">					总之就是，spinlock就是一个整数来维护。0表示无锁，1表示有锁。</span><br><span class="line">					配套的API包括__raw_spin_lock和__raw_spin_unlock。</span><br><span class="line">					__raw_spin_lock会持续判断lock的值是否等于0，如果不等于0（locked）那么其他thread已经持有该锁，</span><br><span class="line">					本thread就不断的spin，判断lock的数值，一直等到该值等于0为止，一旦探测到lock等于0，那么就设定该值为1，表示本thread持有该锁了，</span><br><span class="line">					当然，这些操作要保证原子性，细节和exclusive版本的ldr和str（即ldrex和strexeq）相关，这里略过。</span><br><span class="line">					离开临界区后，持锁thread会调用__raw_spin_unlock函数解锁。</span><br><span class="line">					这种做法最大的问题，就是不公平。</span><br><span class="line">					在单核时代，对锁的竞争不太激烈的时候，没问题。</span><br><span class="line">					到了多核，很多个进程对锁竞争，无序的争抢spin lock，谁先抢到谁先得，不管thread等了很久还是刚刚开始spin。</span><br><span class="line">					测试表明，在8核的机器上，很多个进程竞争锁，有个进程居然饥饿的等待1000000次。</span><br><span class="line">				新内核：</span><br><span class="line">					4.4内核里的定义：</span><br><span class="line">					typedef struct &#123; </span><br><span class="line">					     union &#123; </span><br><span class="line">					         u32 slock; </span><br><span class="line">					         struct __raw_tickets &#123; </span><br><span class="line">					             u16 owner; </span><br><span class="line">					             u16 next; </span><br><span class="line">					         &#125; tickets; </span><br><span class="line">					     &#125;; </span><br><span class="line">					 &#125; arch_spinlock_t; </span><br><span class="line">					可以看到，相比早期的版本，新的spinlock结构体，内容已经和老的完全不一样了。	</span><br><span class="line">					这里引入的是ticket-based spin lock的概念。</span><br><span class="line">					比方就是出去吃饭，遇到排队，要领号。这里的ticket就是号。</span><br><span class="line">					即使临界区资源可以申请，也要根据排队的号来申领。</span><br><span class="line">					回到arch_spinlock_t。owner就是当前已经入席的那个号码，也就是当前持有锁的那个人的号码。</span><br><span class="line">					next记录的是下一个要分发的号码。</span><br><span class="line">					至于slock，可以看到这其实是个union数据类型。所以slock其实是owner加上next的合体。</span><br><span class="line">					典型的情景如下：</span><br><span class="line">					1.一开始的时候，slock是0.也就是说owner和next都是0.owner和next相等，表示未加锁。</span><br><span class="line">					2.第一个进程申请spinlock，并且让next++。(owner=0|next=1)假设第一个进程用完了临界区，释放了锁。此时把owner++。(owner=1|next=1)</span><br><span class="line">					3.这时候又来了个进程，要申请spinlock.这时候因为之前的进程已经解锁了。所以现在这个进程没排队，直接领号1，并且获得锁，next++。(owner=1|next=2)</span><br><span class="line">					4.假设owner1这个进程，动作非常慢。后面来的进程，申请spinlock失败，则马上领号2(因next=2)，并把next++.(owner=1|next=3)</span><br><span class="line">					5.假设owner1还在占用锁。再后面来的就从3号开始领号。领一次号，next++。3，4，5，6.。。。如此继续排队。</span><br><span class="line">					6.owner1解锁。这时候紧跟着排队的owner2才有资格获得锁。</span><br><span class="line"></span><br><span class="line">				代码实现（以新内核+v6以后的32位ARM为例分析）</span><br><span class="line">				static inline void arch_spin_lock(arch_spinlock_t *lock) </span><br><span class="line">				 &#123; </span><br><span class="line">				     unsigned long tmp; </span><br><span class="line">				     u32 newval; </span><br><span class="line"> 				    arch_spinlock_t lockval; </span><br><span class="line"></span><br><span class="line">				    prefetchw(&amp;lock-&gt;slock);－－－－－－－－－－－－－－－－－－－－－－－－（1） </span><br><span class="line">				    __asm__ __volatile__( </span><br><span class="line">				 &quot;1:    ldrex    %0, [%3]\n&quot;－－－－－－－－－－－－－－－－－－－－－－－－－（2） </span><br><span class="line">				&quot;    add    %1, %0, %4\n&quot; </span><br><span class="line">				 &quot;    strex    %2, %1, [%3]\n&quot;－－－－－－－－－－－－－－－－－－－－－－－－（3） </span><br><span class="line">				&quot;    teq    %2, #0\n&quot;－－－－－－－－－－－－－－－－－－－－－－－－－－－－（4） </span><br><span class="line">				&quot;    bne    1b&quot; </span><br><span class="line">				     : &quot;=&amp;r&quot; (lockval), &quot;=&amp;r&quot; (newval), &quot;=&amp;r&quot; (tmp) </span><br><span class="line"> 				    : &quot;r&quot; (&amp;lock-&gt;slock), &quot;I&quot; (1 &lt;&lt; TICKET_SHIFT) </span><br><span class="line"> 				    : &quot;cc&quot;); </span><br><span class="line"></span><br><span class="line">				    while (lockval.tickets.next != lockval.tickets.owner) &#123;－－－－－－－－－－－－（5） </span><br><span class="line">				        wfe();－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（6） </span><br><span class="line">				        lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner);－－－－－－（7） </span><br><span class="line">				    &#125; </span><br><span class="line"></span><br><span class="line">				    smp_mb();－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（8） </span><br><span class="line">				&#125; </span><br><span class="line">				（1）和preloading cache相关的操作，主要是为了性能考虑，不是重点。 </span><br><span class="line">				（2）将&amp;lock-&gt;slock的值，通过ldrex保存在lockval这个临时变量中 。注意这里用了ldrex和strex，来保证操作原子性。</span><br><span class="line">				（3）将spin lock中的next加一。同样为原子操作的指令。strex。</span><br><span class="line">				（4）判断是否有其他的thread插入刚刚的ldrex和strex原子操作。如果说没有人打断刚刚的原子操作，至此就完成了next++这个领号的动作。</span><br><span class="line">				（5）判断当前spin lock的状态，如果是unlocked，那么直接获取到该锁 </span><br><span class="line">				（6）如果当前spin lock的状态是locked，那么调用wfe进入等待状态。注意这里并非真的用white(1)循环去傻傻地等。</span><br><span class="line">					wfe其实本质上是让当前执行这个指令的cpu核，进入低功耗状态等待。当别的cpu核执行了SEV指令（当spinlock解锁时），会唤醒其他cpu核。</span><br><span class="line">					这样子，相比老内核+老的ARM核，傻傻的while循环去等。wfe至少做到了把功耗降下来，硬件上进入休眠。（详见下面针对WFE的解释）</span><br><span class="line">				（7）其他的CPU通过SEV指令唤醒了本cpu的执行，说明owner发生了变化，该新的own赋给lockval，然后继续判断spin lock的状态，也就是回到step 5。 </span><br><span class="line">					换句话说。如果某个cpu核，释放了锁。这时候通知所有等待锁的cpu核起床了。起床后，更新当前的owner，再各自检查下，是不是轮到自己了。</span><br><span class="line">					是自己，就去干活。不是自己，接着睡觉。</span><br><span class="line">					另外。这里用到了ACCESS_ONCE()，详见下面的解释.</span><br><span class="line">					顺便看一眼，解锁spinlock的时候，是怎么发出SEV指令的：</span><br><span class="line">					static inline void arch_spin_unlock(arch_spinlock_t *lock)</span><br><span class="line">					&#123;</span><br><span class="line">						smp_mb();	//内存屏障相关</span><br><span class="line">						lock-&gt;tickets.owner++;</span><br><span class="line">						dsb_sev();</span><br><span class="line">					&#125;</span><br><span class="line">					可以看到，除了owner++的动作。还有个语句就是dsb_sev();。</span><br><span class="line">					static inline void dsb_sev(void)</span><br><span class="line">					&#123;</span><br><span class="line">						dsb(ishst);	//指令乱序相关</span><br><span class="line">						__asm__(SEV);</span><br><span class="line">					&#125;</span><br><span class="line">					__asm__(SEV);就是SEV指令所在了。</span><br><span class="line">				（8）memory barrier的操作，不是重点。</span><br><span class="line">	</span><br><span class="line">				上面的代码是32位的ARM.那么最新的64位ARM，是怎么实现的？</span><br><span class="line">				arch\arm64\include\spinlock.h</span><br><span class="line">				static inline void arch_spin_lock(arch_spinlock_t *lock)</span><br><span class="line">				&#123;</span><br><span class="line">					unsigned int tmp;</span><br><span class="line">					arch_spinlock_t lockval, newval;</span><br><span class="line"></span><br><span class="line">					asm volatile(</span><br><span class="line">					/* Atomically increment the next ticket. */</span><br><span class="line">					ARM64_LSE_ATOMIC_INSN(</span><br><span class="line">					/* LL/SC */</span><br><span class="line">				&quot;	prfm	pstl1strm, %3\n&quot;</span><br><span class="line">				&quot;1:	ldaxr	%w0, %3\n&quot;</span><br><span class="line">				&quot;	add	%w1, %w0, %w5\n&quot;</span><br><span class="line">				&quot;	stxr	%w2, %w1, %3\n&quot;</span><br><span class="line">				&quot;	cbnz	%w2, 1b\n&quot;,</span><br><span class="line">					/* LSE atomics */</span><br><span class="line">				&quot;	mov	%w2, %w5\n&quot;</span><br><span class="line">				&quot;	ldadda	%w2, %w0, %3\n&quot;</span><br><span class="line">				&quot;	nop\n&quot;</span><br><span class="line">				&quot;	nop\n&quot;</span><br><span class="line">				&quot;	nop\n&quot;</span><br><span class="line">					)</span><br><span class="line"></span><br><span class="line">					/* Did we get the lock? */</span><br><span class="line">				&quot;	eor	%w1, %w0, %w0, ror #16\n&quot;</span><br><span class="line">				&quot;	cbz	%w1, 3f\n&quot;</span><br><span class="line">					/*</span><br><span class="line">					 * No: spin on the owner. Send a local event to avoid missing an</span><br><span class="line">					 * unlock before the exclusive load.</span><br><span class="line">					 */</span><br><span class="line">				&quot;	sevl\n&quot;</span><br><span class="line">				&quot;2:	wfe\n&quot;</span><br><span class="line">				&quot;	ldaxrh	%w2, %4\n&quot;</span><br><span class="line">				&quot;	eor	%w1, %w2, %w0, lsr #16\n&quot;</span><br><span class="line">				&quot;	cbnz	%w1, 2b\n&quot;</span><br><span class="line">					/* We got the lock. Critical section starts here. */</span><br><span class="line">				&quot;3:&quot;</span><br><span class="line">					: &quot;=&amp;r&quot; (lockval), &quot;=&amp;r&quot; (newval), &quot;=&amp;r&quot; (tmp), &quot;+Q&quot; (*lock)</span><br><span class="line">					: &quot;Q&quot; (lock-&gt;owner), &quot;I&quot; (1 &lt;&lt; TICKET_SHIFT)</span><br><span class="line">					: &quot;memory&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				总的来说就是ARM64的指令，其实相比ARM32的指令，变化还是很多的。</span><br><span class="line">				详细的分析以后有时间再一句一句看。</span><br><span class="line">					32位的ldrex进化成了ldaxr.这个新指令被称为Load-Acquire/Store-Release。这是ARMv8的新指令。</span><br><span class="line">					意思是执行load和store操作的时候顺便执行了memory barrier相关的操作.</span><br><span class="line"></span><br><span class="line">				相关知识之WFE指令（也介绍下WFI指令）</span><br><span class="line">					WFI(Wait for interrupt)和WFE(Wait for event)是两个让ARM核进入low-power standby模式的指令</span><br><span class="line">					主要是“将ARM PE(Processing Element, 处理单元)设置为low-power standby state”。</span><br><span class="line">					WFI/WFE的区别：</span><br><span class="line">						WFI来说，执行WFI指令后，ARM core会立即进入low-power standby state，直到有WFI Wakeup events发生。</span><br><span class="line">						而WFE则稍微不同，执行WFE指令后，根据Event Register（一个单bit的寄存器，每个PE一个）的状态，有两种情况：</span><br><span class="line">						如果Event Register为1，该指令会把它清零，然后执行完成（不会standby）；如果Event Register为0，和WFI类似，	</span><br><span class="line">						进入low-power standby state，直到有WFE Wakeup events发生。</span><br><span class="line">						所以说，WFI和WFE，在入睡的条件上，是不一样的。</span><br><span class="line">						在唤醒的条件上，也略有不同：</span><br><span class="line">						WFI唤醒条件：</span><br><span class="line">							收到WFI wakeup event</span><br><span class="line">							IRQ各种中断</span><br><span class="line">						WFE唤醒条件：</span><br><span class="line">							收到WFE wakeup event</span><br><span class="line">							IRQ各种中断</span><br><span class="line">							但注意，WFE可以被任何PE（也就说从任何一个cpu核上）上执行的SEV指令，所产生的wakeup event唤醒。</span><br><span class="line">					所谓的SEV指令，就是一个用来改变Event Register的指令，有两个：SEV会修改所有PE上的寄存器；SEVL，只修改本PE的寄存器值。</span><br><span class="line"></span><br><span class="line">				相关知识之ACCESS_ONCE()	</span><br><span class="line">					#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</span><br><span class="line">					从定义就可以看出，ACCESS_ONCE()其实就是加了个volatile。</span><br><span class="line">					使用ACCESS_ONCE修饰过的语句，编译器就被告知，不要去优化这句话。</span><br><span class="line">		自旋锁使用不当的几种情况举例：</span><br><span class="line">		1.禁止递归使用自旋锁。一个已经获得锁的进程，如果再次申请锁，会造成死锁。</span><br><span class="line">		2.获取锁后，不能在调用引起进程调度的函数。比如copy_from_user(),kmalloc(),mseelp()。原因比较复杂。详见“Linux内核：spinlock和睡眠.pdf”</span><br><span class="line">			简单来说，首先spinlock本来就要求快速访问完临界区。这时候去睡眠，从逻辑上就不合理。</span><br><span class="line">			细说的话，“Linux内核：spinlock和睡眠.pdf”讨论了几种单/多核+开/关抢占的情形。但结论都是不应该睡眠。“Linux内核：spinlock和睡眠.pdf”文中已经有详细说明。</span><br><span class="line"></span><br><span class="line">		UP情况下，中断里面，无论如何是无需spinlock的？</span><br><span class="line">			假设是中断之间竞争锁。那么中断里面是关中断禁止嵌套的，各个中断自然都无需上锁。</span><br><span class="line">			假设是线程和中断之间竞争锁。那么首先这时候线程上锁，就已经需要关中断。</span><br><span class="line">				如果线程先占有的锁，这时候因为用了诸如spin_lock_irqsave来关中断，那么中断就进不来。中断自然不用上锁。</span><br><span class="line">				如果是中断先访问的临界区，即使是抢占式内核，也要等到中断返回，线程才有机会再次去访问临界区，而这时候中断早退出了。</span><br><span class="line">			综合之下似乎是这么个考虑。</span><br><span class="line">	硬件自旋锁</span><br><span class="line">		参考《Hardware spinlock.pdf》</span><br><span class="line">		用于异构核间的锁操作(跨核跨操作系统)。比如：AP核需要操作某个spi口，而MCU小核也可能操作同一路spi。</span><br><span class="line">		AP核运行linux，mcu运行rtos。核不一样，os也不一样。这时候就需要一种硬件的spinlock来完成独占。‘</span><br><span class="line">		这个锁是全局都可以使用的，都可以申请，不和具体的总线类型/总线号绑定。也就是说，你可以规定22号hwspinlock用于spi0.也可以自定义23号锁用于spi0.</span><br><span class="line">		SOC的平台代码通过hwspin_lock_register注册。</span><br><span class="line">		使用者可以用hwspin_lock_request_specific来申请特定编号的硬件自旋锁。</span><br><span class="line">		例子代码：</span><br><span class="line">			int hwspinlock_example2(void)</span><br><span class="line">			&#123;</span><br><span class="line">				struct hwspinlock *hwlock;</span><br><span class="line">				int ret;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				* assign a specific hwspinlock id - this should be called early</span><br><span class="line">				* by board init code.</span><br><span class="line">				*/</span><br><span class="line">				hwlock = hwspin_lock_request_specific(PREDEFINED_LOCK_ID);</span><br><span class="line">				if (!hwlock)</span><br><span class="line">					...</span><br><span class="line"></span><br><span class="line">				/* try to take it, but don&apos;t spin on it */</span><br><span class="line">				ret = hwspin_trylock(hwlock);</span><br><span class="line">				if (!ret) &#123;</span><br><span class="line">					pr_info(&quot;lock is already taken\n&quot;);</span><br><span class="line">					return -EBUSY;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/*</span><br><span class="line">				* we took the lock, do our thing now, but do NOT sleep</span><br><span class="line">				*/</span><br><span class="line"></span><br><span class="line">				/* release the lock */</span><br><span class="line">				hwspin_unlock(hwlock);</span><br><span class="line"></span><br><span class="line">				/* free the lock */</span><br><span class="line">				ret = hwspin_lock_free(hwlock);</span><br><span class="line">				if (ret)</span><br><span class="line">					...</span><br><span class="line">				return ret;</span><br><span class="line">			&#125;</span><br><span class="line">	信号量								-仅能用于进程上下文，会导致睡眠</span><br><span class="line">		分两种，semaphore和mutex</span><br><span class="line">		不能用于中断(除了down_trylock())</span><br><span class="line">		如果是可以多次进入的信号量，则用sema_init初始化。如果是只能进入一次的互斥量，则用DECLARE_MUTEX初始化。</span><br><span class="line">		mutex_lock()，mutex_unlock()</span><br><span class="line">		down(),up()</span><br><span class="line">		down_interruptible()	</span><br><span class="line">			睡眠过程中，如果获得信号（如kill信号），则醒来返回一个错误的值-EINTR	</span><br><span class="line">			这个和down()的区别是，万一产生死锁，至少还能接收外部的例如kill的信号，这样能用ctrl+C来杀死进程。</span><br><span class="line">		down_trylock()，这个不会引起睡眠，可以在中断里面使用，是个特例。如果获取锁失败，就返回错误。</span><br><span class="line">		mutex有以下的限制：</span><br><span class="line">			1）同一时间只能有一个进程获得锁，这是互斥的概念。</span><br><span class="line">			2）只能在同一进程上锁和解锁，而信号量不一样，可以在这个进程上锁，另外的进程解锁。</span><br><span class="line">			3）同一个进程获得锁后这段期间不能再获得这个锁，也就是说不能递归使用，原因很简单，因为是互斥，上锁的只有一次，只能解锁有在上锁。</span><br><span class="line">			4）进程持有锁是不能退出。</span><br><span class="line">			5）中断上下文不能使用锁，即使是mutex_trylock()。</span><br><span class="line">			6）互斥锁只能通过内核提供的API接口来操作。</span><br><span class="line">		但把semaphore的value设置成1，当成mutex来使用的做法是不合适的。因为mutex和semaphore设计初衷是不同的。举个例子：</span><br><span class="line">		在早餐餐厅，大家要喝咖啡。如果用Mutex的方式，同时只有一个人可以使用咖啡机，他获得了咖啡机的使用权后，开始做咖啡，其他人只能在旁边等着，</span><br><span class="line">		直到他做好咖啡后，另外一个人才能获得咖啡机的使用权。</span><br><span class="line">		如果用Semaphore的模式，服务员会把咖啡做好放到柜台上，谁想喝咖啡就拿走一杯，服务员会不断做咖啡，如果咖啡杯被拿光了，想喝咖啡的人就排队等着。</span><br><span class="line">		Mutex管理的是咖啡机的使用权，而Semaphore管理的是做好的咖啡数量。</span><br><span class="line">		而因为semaphore用于管理资源的数量，涉及了两方面：资源生产者和消费者。通过生产者和消费者的互斥，可以用于线程间的信息同步，这也是信号量的含义。</span><br><span class="line">		而mutex只能用于临界区的互斥。</span><br><span class="line">		一个最典型的使用semaphore的场景：</span><br><span class="line">		a源自一个线程，b源自另一个线程，计算c = a + b也是一个线程。（即一共三个线程）</span><br><span class="line">		显然，第三个线程必须等第一、二个线程执行完毕它才能执行。伪代码如下：</span><br><span class="line">		int a, b, c;</span><br><span class="line">		semaphore sem(0); // 一开始是没资源的，要生产者A,B来生产。</span><br><span class="line">		void geta()</span><br><span class="line">		&#123;</span><br><span class="line">			a = calculatea();</span><br><span class="line">			semaphore_increase();</span><br><span class="line">		&#125;</span><br><span class="line">		void getb()</span><br><span class="line">		&#123;</span><br><span class="line">			b = calculateb();</span><br><span class="line">			semaphore_increase();</span><br><span class="line">		&#125;</span><br><span class="line">		void getc()</span><br><span class="line">		&#123;</span><br><span class="line">			semaphore_decrease();</span><br><span class="line">			semaphore_decrease();</span><br><span class="line">			c = a + b;</span><br><span class="line">		&#125;</span><br><span class="line">		t1 = thread_create(geta);</span><br><span class="line">		t2 = thread_create(getb);</span><br><span class="line">		t3 = thread_create(getc);</span><br><span class="line">		thread_join(t3);</span><br><span class="line">		这个例子中，只有geta和getb完成以后，getc才有机会执行。</span><br><span class="line">		例子代码：Linux\Kernel\并发和竞态\code\semaphore_sync_1\</span><br><span class="line">		先执行A,再执行C，再执行B。可以看到C是睡眠的，直到B进程来了以后才唤醒。</span><br><span class="line">		再举个例子，2个厕所，有3个人想上。</span><br><span class="line">		semaphore sem(2);  // 同时执行的线程数量上限为2，即一共2个厕所</span><br><span class="line">		void PeopleGoToToilet_A()</span><br><span class="line">		&#123;</span><br><span class="line">			semaphore_decrease(sem);</span><br><span class="line">			// do something</span><br><span class="line">			semaphore_increase(sem);</span><br><span class="line">		&#125;</span><br><span class="line">		void PeopleGoToToilet_B()</span><br><span class="line">		&#123;</span><br><span class="line">			semaphore_decrease(sem);</span><br><span class="line">			// do something</span><br><span class="line">			semaphore_increase(sem);</span><br><span class="line">		&#125;</span><br><span class="line">		void PeopleGoToToilet_C()</span><br><span class="line">		&#123;</span><br><span class="line">			semaphore_decrease(sem);</span><br><span class="line">			// do something</span><br><span class="line">			semaphore_increase(sem);</span><br><span class="line">		&#125;</span><br><span class="line">		t1 = thread_create(PeopleGoToToilet_A);</span><br><span class="line">		t2 = thread_create(PeopleGoToToilet_B);</span><br><span class="line">		t3 = thread_create(PeopleGoToToilet_C);</span><br><span class="line">		thread_join(toiletA);</span><br><span class="line">		thread_join(toiletB);</span><br><span class="line">		thread_join(toiletC);</span><br><span class="line">		例子代码：Linux\Kernel\并发和竞态\code\semaphore_sync_2\</span><br><span class="line">		但这又有另外一个问题。如果消费者非常多，生产者很少，狼多肉少，所以很多消费者在down后等待，结果up来了，肉先给谁吃？会有竞争不公平的问题。</span><br><span class="line">		这和ticket-based spin lock所涉及的问题一样。这个问题没有答案，因为semaphore是为同步而设计的，而不是为了解决竞争问题而设计的。</span><br><span class="line"></span><br><span class="line">	读写锁（读者仅当和别的读者竞争则不会阻塞，其余情况全会阻塞，包括写操作本身也可能被阻塞）</span><br><span class="line">		读者之间无竞争，写者是独占性的，会合其他的读者和写者竞争。适用于很多读者和少量写者的情况，如路由表的访问。</span><br><span class="line">		read_lock(),read_unlock(),write_lock(),write_unlock()</span><br><span class="line">		read_lock_irqsave()类似于spin_lock_irqsave()的变种</span><br><span class="line">		定义：</span><br><span class="line">		static DEFINE_RWLOCK(xxx_lock);</span><br><span class="line">		使用：</span><br><span class="line">		写的时候，使用write_lock(&amp;xxx_lock)</span><br><span class="line">		读的时候，使用read_lock(&amp;xxx_lock);</span><br><span class="line">		所以这个锁的特点是啥？</span><br><span class="line">		1.读的操作占多数。且读和读之间要求不阻塞。</span><br><span class="line">		2.写的操作很罕见，但一旦写，会独占，导致暂时不能读。但写可以短时间被读者阻塞下，这是和顺序锁的区别。</span><br><span class="line"></span><br><span class="line">	顺序锁（写者完全不会阻塞）</span><br><span class="line">		读写锁的变种，除了读写锁的功能以外，还能保证写的时候还能读，只是写的时候不能再来一个写的人。</span><br><span class="line">		和读写锁相比，适用于写者不希望被读者阻塞的情况。例如读取jiffies_64的函数u64 get_jiffies_64(void)</span><br><span class="line">		同时，因为读的时候可以写，那么这种读写同时发生的情况，有一个unsigned sequence变量来提示是不是读的时候有人在写，</span><br><span class="line">		如果有，那就要多读一次或者几次</span><br><span class="line">		write_seqlock_irqsave</span><br><span class="line">		read_seqbegin_irqsave</span><br><span class="line">		定义：</span><br><span class="line">		DEFINE_SEQLOCK(xxx_lock);</span><br><span class="line">		使用：</span><br><span class="line">		写的时候write_seqlock</span><br><span class="line">		读的时候，用read_seqbegin获取序列号，如果用read_seqretry检查序列号返回的是奇数，则表示正在有人写入，这时候</span><br><span class="line">		所以这个锁的特点是啥？</span><br><span class="line">		1.A small amount of data is to be protected.</span><br><span class="line">		2.That data is simple (no pointers), and is frequently accessed.</span><br><span class="line">		3.Access to the data does not create side effects.</span><br><span class="line">		4.It is important that writers not be starved for access.</span><br><span class="line">		正如上面所说，最合适的就是jiffies了。到了时间点，必须更新时间，不能阻塞写者。至于读者，可能读的不准确，那就多读数次。</span><br><span class="line">		如何保证写者不被阻塞？意味着从机制上设计，写者可以随时打断读者。这样读者就有可能需要反复对读的结果确认。</span><br><span class="line">		这就是顺序锁的思路。</span><br><span class="line"></span><br><span class="line">	读-拷贝-修改锁RCU锁Read-Copy Update（读者完全不会阻塞，但可能读到旧的数据）</span><br><span class="line">		参见《Linux RCU 内核同步机制.pdf》</span><br><span class="line">		写的时候，先写到一个拷贝出来的副本。还有读者的时候，就睡眠，等所有读者读完再唤醒去写。</span><br><span class="line">		读的时候，不需要持有任何锁（但仍需要调用rcu_read_lock更新标志位）。</span><br><span class="line">		适用于读取量很大、而且可以接受读取到旧数据的场景。一个典型场景就是内核路由表，</span><br><span class="line">		路由表的更新是由外部触发的，外部环境的延迟远比内核更新延迟高，</span><br><span class="line">		在内核更新路由表前实际已经向旧路径转发了很多数据包，RCU读者按照旧路径再多转发几个数据包是完全可以接受的，</span><br><span class="line"></span><br><span class="line">	Completion Interface</span><br><span class="line">		用于同步，也是一种锁机制。比信号量简单。如果不关心资源数目，只关心完成/未完成这种线程的同步等待关系，则应该用Completion更简单。</span><br><span class="line">		使用completion可以一次性唤醒所有等待进程。</span><br><span class="line">		完成completion的一方：</span><br><span class="line">			DECLARE_COMPLETION</span><br><span class="line">			complete_and_exit()或者complete() </span><br><span class="line">		等待completion的一方：</span><br><span class="line">			wait_for_completion();等待对方完成，未完成则睡眠</span><br><span class="line">			wait_for_completion_timeout()在上面的基础上，加入了超时，超过时间自动唤醒。</span><br><span class="line">		例子代码：Linux\Kernel\并发和竞态\code\completion</span><br><span class="line">		参考：《并发：completion 机制》</span><br><span class="line">	相关文档：</span><br><span class="line">		http://www.ibm.com/developerworks/cn/linux/l-synch/part1/index.html</span><br><span class="line">		http://www.ibm.com/developerworks/cn/linux/l-synch/part2/index.html</span><br><span class="line">		Linux\Kernel\学习资料\linux设备驱动归纳总结（四）：5_SMP下的竞态和并发.pdf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实践之semaphore的使用：</span><br><span class="line">	以am335x用i2c连接的pca9552芯片驱动为例。</span><br><span class="line">	这个芯片，一共有16路led输出。</span><br><span class="line">	驱动会针对每个led输出，都用INIT_WORK创建各自的work。</span><br><span class="line">	当用户在/sys/class/leds下操作的时候，最终就会去调用pca955x_led_work这个workqueue的work。</span><br><span class="line">	pca955x_led_work代码如下：</span><br><span class="line"></span><br><span class="line">	static void pca955x_led_work(struct work_struct *work)</span><br><span class="line">	&#123;</span><br><span class="line">	struct pca955x_led *pca955x;</span><br><span class="line">	u8 ls;</span><br><span class="line">	int chip_ls;	/* which LSx to use (0-3 potentially) */</span><br><span class="line">	int ls_led;	/* which set of bits within LSx to use (0-3) */</span><br><span class="line"></span><br><span class="line">	if (down_interruptible (&amp;pca95xx_semaphore))</span><br><span class="line">		return;</span><br><span class="line">	</span><br><span class="line">	pca955x = container_of(work, struct pca955x_led, work);</span><br><span class="line">	</span><br><span class="line">	chip_ls = pca955x-&gt;led_num / 4;</span><br><span class="line">	ls_led = pca955x-&gt;led_num % 4;</span><br><span class="line"></span><br><span class="line">	ls = pca955x_read_ls(pca955x-&gt;client, chip_ls);			//先读取</span><br><span class="line">	</span><br><span class="line">	switch (pca955x-&gt;brightness) &#123;				//更改</span><br><span class="line">	case LED_FULL:</span><br><span class="line">		ls = pca955x_ledsel(ls, ls_led, PCA955X_LS_LED_ON);</span><br><span class="line">		break;</span><br><span class="line">	case LED_OFF:</span><br><span class="line">		ls = pca955x_ledsel(ls, ls_led, PCA955X_LS_LED_OFF);</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pca955x_write_ls(pca955x-&gt;client, chip_ls, ls);			//再写入</span><br><span class="line"></span><br><span class="line">	up(&amp;pca95xx_semaphore);</span><br><span class="line">	&#125;</span><br><span class="line">	假设在用户空间，用户在一个脚本里面，顺序执行操作led的命令：</span><br><span class="line">	echo 255 &gt; /sys/class/leds/ledpad0-0/brightness</span><br><span class="line">	echo 255 &gt; /sys/class/leds/ledpad0-1/brightness</span><br><span class="line">	echo 255 &gt; /sys/class/leds/ledpad0-2/brightness</span><br><span class="line">	...</span><br><span class="line">	echo 255 &gt; /sys/class/leds/ledpad0-15/brightness</span><br><span class="line">	一共有15个workqueue内核线程在跑。</span><br><span class="line">	在不是用sempahore机制的前提下。因为顺序执行，cpu速度较快，其实几乎每次i2c操作（除了开头的一次），都会导致睡眠。</span><br><span class="line">	睡眠导致对应的workqueue线程换出，换入了下一个workqueue线程。</span><br><span class="line">	从而导致，某个workqueue线程在尚未完全做好读/改/写的操作之前，就被别的workqueue插入。</span><br><span class="line">	打了个log可以看到：（以led12和led13两颗led为例）</span><br><span class="line">	read begin led_num=12 chip_ls=3	</span><br><span class="line">			&lt;----led12 i2c_smbus_read_byte_data()操作睡眠，导致换到led13的workqueue执行</span><br><span class="line">	read begin led_num=13 chip_ls=3</span><br><span class="line">			&lt;----led13 i2c_smbus_read_byte_data()操作睡眠，导致换到led12的workqueue执行，此时led12睡醒了，可以继续进行i2c读操作</span><br><span class="line">	read end led_num=12 chip_ls=3 ls=0x55</span><br><span class="line">	write begin led_num=12 chip_ls=3 ls=0x54</span><br><span class="line">			&lt;----led12 i2c_smbus_write_byte_data()操作睡眠，导致换到led13的workqueue执行，此时led13睡醒了，可以继续进行i2c读操作</span><br><span class="line">	read end led_num=13 chip_ls=3 ls=0x55</span><br><span class="line">	write begin led_num=13 chip_ls=3 ls=0x51</span><br><span class="line">			&lt;----led13 i2c_smbus_write_byte_data()操作睡眠，导致换到led12的workqueue执行，此时led12睡醒了，可以继续进行i2c写操作</span><br><span class="line">	write end led_num=12 chip_ls=3 ls=0x54</span><br><span class="line">	write end led_num=13 chip_ls=3 ls=0x51</span><br><span class="line">	照理说，正确的顺序是：</span><br><span class="line">	read led_num=12 chip_ls=3 ls=0x55</span><br><span class="line">	write led_num=12 chip_ls=3 ls=0x54</span><br><span class="line">	read led_num=13 chip_ls=3 ls=0x54</span><br><span class="line">	write led_num=13 chip_ls=3 ls=0x50</span><br><span class="line">	也就是先做完led12的事情，再做led13的事情。</span><br><span class="line">	但实际上，上面没有锁保护的情况下，可以看到，led12还没开始写，led13就来读了。临界区的完整性被破坏了。</span><br><span class="line">	需要一个总的锁，来保证每个workqueue的操作，是原子的。（涉及持锁睡眠？）</span><br><span class="line">	spinlock在单核cpu上，作用仅仅是禁用抢占。抢占是针对不同的优先级的用户进程之间而言的。</span><br><span class="line">	这里的情形，是几个内核线程之间的关系。这时候关抢占是一点用没有的。</span><br><span class="line">	用semaphore，有效。</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/28/size-t和ssize-t的使用/" rel="next" title="size_t和ssize_t的使用">
                <i class="fa fa-chevron-left"></i> size_t和ssize_t的使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/28/内存管理/" rel="prev" title="内存管理">
                内存管理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Semiyd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">240</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">130</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semiyd</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
