<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="调度和抢占">
<meta property="og:type" content="article">
<meta property="og:title" content="调度和抢占">
<meta property="og:url" content="http://yoursite.com/2018/07/28/调度和抢占/index.html">
<meta property="og:site_name" content="Semiyd&#39;s Blog">
<meta property="og:description" content="调度和抢占">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-28T08:16:27.714Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="调度和抢占">
<meta name="twitter:description" content="调度和抢占">






  <link rel="canonical" href="http://yoursite.com/2018/07/28/调度和抢占/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>调度和抢占 | Semiyd's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Semiyd's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/调度和抢占/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Semiyd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Semiyd's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">调度和抢占
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-28 15:50:31 / Modified: 16:16:27" itemprop="dateCreated datePublished" datetime="2018-07-28T15:50:31+08:00">2018-07-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/" itemprop="url" rel="index"><span itemprop="name">Kernel</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/调度和抢占/" itemprop="url" rel="index"><span itemprop="name">调度和抢占</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><center><strong>调度和抢占</strong></center><br><a id="more"></a><br>抢占：<br>    所谓抢占，就是指进程间的切换。<br>    那么用户的进程，因为执行的时候，分为在用户空间还是内核空间（通过系统调用进入）执行。<br>    所以也就分在用户空间还是内核空间执行两种情况讨论。<br>    用户空间运行：<br>        假设进程A在执行。此时来了个硬件中断，打断了进程A.等中断执行完毕的时候，如果此时有更高优先级的进程B在排队的话。那么就会抢先A而直接执行B。<br>        等B的时间片用完后，再执行A剩下来的部分。<br>        也就是说，用户空间总是可抢占的。<br>    内核空间运行：<br>        参见同级目录    抢占示意图.png<br>        假设进程A在执行。后来A调用了系统调用，进入了内核态。<br>        然后在内核态，因为访问一下关键的数据，进入critical section。<br>        此时，如果突然来了个硬件中断。则A的系统调用由此被中断打断。<br>        那么假设在中断中，唤醒了一个更高优先级的任务。<br>        在中断退出后，回到A的系统调用，因为此时系统调用仍然在critical section<br>        需要往前跑几步，才能跑出critical section。<br>        那么现在关键来了。<br>        如果是非抢占的内核，此时需要等到A的系统调用完全完成，才会切换到高优先级的任务。（尽管此时A其实也还没完全完成，因为仅仅是完成了他的系统调用部分）<br>        如果是抢占式内核，则一旦出了critical section，则马上被强制切换到高优先级任务。(因为critical section出于保护，是关闭抢占的)<br>            等高优先级任务完成后，再返回到A的系统调用，等A的系统调用完成了，再完成A剩下部分的代码的执行。</p>
<p>抢占的API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preempt_enable()</span><br><span class="line">preempt_disable()</span><br></pre></td></tr></table></figure></p>
<p>抢占的时机：<br>        要发生抢占，说白了就是要调用schedule()。<br>        所以发生抢占的时机，就是什么时候schedule()被调用。<br>        那么schedule()调用，分为主动调用和被动调用两种情况。<br>        主动调用，比如当前进程调用了可睡眠的函数，里面最终会去调用schedule()。<br>        被动调用，是指在中断，异常，或者系统调用结束后，可能会去调用schedule()。<br>        主动调用就不用特别分析了。下面主要看看被动调用。<br>        以中断返回为例：<br>        在do_IRQ()返回后，会调用ret_from_except()。<br>        那么这个ret_from_except()，会去检查，当前中断打断的是用户空间还是内核空间的程序。<br>        如果打断的是用户空间，则在ret_from_except的最后，就直接去调用schedule。<br>        这就是为什么，在用户空间运行的时候，进程始终是可以被抢占的。(也就是进程在没有调用系统调用，仅仅在用户态执行的时候)<br>        那么如果打断的是内核空间，在ret_from_except的最后，如果内核支持抢占的话，这时候也会最后去调用schedule。<br>        这样就实现了中断返回的时候对内核态的抢占。</p>
<p>进程的状态：<br>    进程状态分为5种：<br>        TASK_RUNNING<br>            处于运行状态或者在就绪的队列里<br>        TASK_INTERRUPTIBLE<br>            处于等待某个信号/事件的浅睡状态。如果事件发生，就会变成TASK_RUNNING<br>            事件是指wait queue的这种事件<br>            信号是指kill, raise, alarm等系统信号。如SIGKILL<br>            此时不处于run queue里面了。<br>        TASK_UNINTERRUPTIBLE<br>            处于等待某个事件的深睡状态。只能被wake_up()唤醒。<br>            但不能被信号打断，比如被kill掉或被信号放入run queue。适用于不能被打断的处理流程，不太常用。<br>        TASK_STOPPED<br>            处于停止状态<br>        TASK_TRACED<br>            strace的时候debug的状态<br>            除了上面5种状态，还有下面两种特殊的状态。<br>        EXIT_ZOMBIE<br>            进程本身已经终止，但父进程尚没有调用wait 系统调用来清除它的僵尸孩子。<br>        EXIT_DEAD<br>            终止状态<br>    那么内核针对这些不同状态的进程，是如何统一归类管理的呢？<br>    与TASK_RUNNING相关的有struct rq{}结构体，也就是per-CPU runqueue data structure，定义位于kernel/sched.c。运行队列链表rq把处于TASK_RUNNING状态的所有进程组织在一起。<br>    至于TASK_STOPPED、EXIT_ZOMBIE 或 EXIT_DEAD，没有他们建立专门的链表。<br>    由于处于暂停、僵死、死亡状态进程的访问比较简单，或者通过PID，或者通过特定父进程的子进程链表，所以不必对这三种状态进程分组。<br>    对于处于TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE状态的进程则由waitqueue来管理。详见    Linux\Kernel\阻塞和非阻塞\阻塞\waitqueue\</p>
<p>进程优先级的确定：<br>nice值：<br>        范围是-20到19，一共40级。默认值是0<br>        值越小，优先级越高。<br>        可以用nice命令，对将要运行的程序进行优先级的设置<br>        nice -n 10 app<br>        这样app的nice就是10.<br>        另外，可以用renice命令，对一个正在运行的进程进行nice值的调整。<br>        renice -5 -p 5200<br>        那么从字面上理解，越nice的人，抢占资源的意愿越弱，也就是nice值越高。<br>        越不nice的人，抢占资源的意愿越强，也就是nice值越低。<br>        那么nice值设定好以后，是不变的。除非用renice去改动它。<br>        所以nice值称为静态优先级。</p>
<p>priority值：<br>        相对于nice值，priority值，就是动态优先级。为什么叫动态？因为内核会根据进程运行的情况，进行动态的微调。（在O1调度算法里面会解释这个细节）<br>        所以priority值本身是不可以改的。要改，只能改nice。等于通过nice去改priority。<br>        nice其实是priority的组成部分。后面会解释为什么。<br>        linux实现140个优先级的范围。和nice一样，值越小，优先级越高。<br>        linux的进程被分为两种，实时进程（也就是RT进程），和非实时进程（非RT进程）<br>        见以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include\linux\sched.h</span><br><span class="line">		#define MAX_USER_RT_PRIO	100</span><br><span class="line">		#define MAX_RT_PRIO		MAX_USER_RT_PRIO</span><br><span class="line">		#define DEFAULT_PRIO		(MAX_RT_PRIO + 20)</span><br><span class="line">		#define MAX_PRIO			(MAX_RT_PRIO + 40)</span><br></pre></td></tr></table></figure></p>
<p>对于非RT进程，优先级最高也就是100（MAX_USER_RT_PRIO），最低就是140（MAX_PRIO）。<br>那么对于非RT进程，默认优先级就是120.<br>如果通过调整nice值，那么nice因为是-20到19.<br>所以最多就是在100~139这个范围内调整。<br>换句话说，对于非RT进程，决定priority，其实靠nice就可以了。<br>对于RT进程，那么他的优先级就是0~99，最大值就是100（MAX_USER_RT_PRIO）</p>
<p>通过ps -l可以查看到nice值和priority值。<br>yandong@CH4WDT22X8DB2:~$ ps -l<br>F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD<br>0 S  1000 25186 12278  0  80   0 -  2186 wait   pts/11   00:00:00 bash<br>0 R  1000 31805 25186  0  80   0 -  1254 -      pts/11   00:00:00 ps</p>
<p>PRI就是priority值。NI是nice值。</p>
<p>所以可以理解为nice值是针对整个优先级进行微调。但是不能通过nice值的调整，把一个非RT进程调整的和RT进程一样的优先。<br>当然，最终真正算数的，是priority。nice其实是priority的组成部分。</p>
<p>另外，这里涉及一个shell命令。chrt。</p>
<p>yandong@CH4WDT22X8DB2:~$ chrt</p>
<p>chrt - manipulate real-time attributes of a process</p>
<p>Set policy:<br>  chrt [options] [<policy>] <priority> [-p <pid> | <command> [<arg>…]]</arg></pid></priority></policy></p>
<p>Get policy:<br>  chrt [options] -p <pid></pid></p>
<p>Scheduling policies:<br>  -b | –batch         set policy to SCHED_BATCH<br>  -f | –fifo          set policy to SCHED_FIFO<br>  -i | –idle          set policy to SCHED_IDLE<br>  -o | –other         set policy to SCHED_OTHER<br>  -r | –rr            set policy to SCHED_RR (default)</p>
<p>Scheduling flags:<br>  -R | –reset-on-fork set SCHED_RESET_ON_FORK for FIFO or RR</p>
<p>Options:<br>  -a | –all-tasks     operate on all the tasks (threads) for a given pid<br>  -h | –help          display this help<br>  -m | –max           show min and max valid priorities<br>  -p | –pid           operate on existing given pid<br>  -v | –verbose       display status information<br>  -V | –version       output version information<br>        这个命令，可以用来查看，设置一个进程的实时优先级状态。<br>        那么，linux针对RT和非RT进程。调度的策略是不同的。<br>        也就是说，针对非RT进程的调度策略，在实时性上，是没法满足RT进程的调度的时间要求的。</p>
<p>针对RT进程的调度策略有：SCHED_RR，SCHED_FIFO<br>    SCHED_RR就是round robin，时间片轮转。时间片是100ms。时间片到了，就换人。很简单。<br>    SCHED_FIFO就是队列方式，优先级一样的情况下，谁先开始执行的，就先调度谁，除非它退出或者让出CPU.<br>针对非RT进程的调度策略有：SCHED_BATCH，SCHED_OTHER,SCHED_IDLE<br>    非RT的调度复杂的多。涉及的调度算法是O1和CFS.有关O1算法和CFS算法，后面在调度的章节里面再具体解释。</p>
<p>系统整体的调度策略是：<br>    如果系统中有RT进程，则优先执行RT进程。直到RT进程退出，或者RT进程主动让出CPU（睡眠）时，才会去调度非RT进程。</p>
<p>那么让一个进程作为RT进程来运行呢？<br>chrt -f 10 app    -f是指用SCHED_FIFO，也就是RT进程的调度方式了。优先级设置为10.<br>chrt -p $$<br>    可以显示当前的进程调度方式是SCHED_FIFO，优先级是10.</p>
<p>调度：<br>    上面说到，RT进程的调度有：<br>        SCHED_RR就是round robin，时间片轮转。时间片是100ms。时间片到了，就换人。很简单。<br>        SCHED_FIFO就是队列方式，优先级一样的情况下，谁先开始执行的，就先调度谁，除非它退出或者让出CPU.<br>    非RT进程的调度有：SCHED_BATCH，SCHED_OTHER,SCHED_IDLE,涉及的调度算法是O1和CFS.<br>    O1和CFS调度算法的细节:<br>        linux 2.6.23以后，O1算法就被CFS算法替换了。所以现在新的内核里面，默认的非RT进程的调度算法，就是CFS。<br>        O1算法：<br>            O1的名字来源于其算法的时间复杂度是O1。<br>            O1是基于时间片分配的思路来设计的。<br>            假设时间片的基本单位是10ms.那么针对优先级高的进程，就会得到较大的时间片。反之优先级低的进程，就获得较小的时间片。（都是10ms的倍数）<br>            即使是nice值一样的进程（对于非RT进程，nice值一样，意味着priority值一样），O1也会根据其对cpu的占用情况，分为两种：cpu消耗型和io消耗型。<br>            顾名思义，cpu消耗型，就是主要做算数运算的程序。并且通常不会主动放弃cpu，除非被打断，或者时间片耗尽。<br>            io消耗型，就是时间片没耗尽，就主动让出cpu了。例如一些交互程序，vi,emacs。<br>            那么现在假设。有两个进程在跑。priority一样。都是默认的120的非RT进程。<br>            nice为0<br>            一个进程是vi。一个进程是算数运算的程序。<br>            那么内核此时因为都是120的优先级。所以会给这两个程序分配相同的时间片长度，假设是500ms.<br>            此时人来输入一个字符。那么很可能此时cpu正在做算数运算。<br>            又因为这两个进程的优先级一样，不存在谁打断谁的问题。所以只好等算数运算的进程时间片结束以后，vi再响应。<br>            这样就会让人觉得很卡顿。<br>            所以针对这种情况。O1算法会把进程区分出来，到底属于cpu消耗型，还是io消耗型。<br>            区分以后，会动态的微调priority值，范围是+-5<br>            这种特定的情况，O1会提高io消耗型的进程的优先级，增加其时间片长度。并且降低cpu消耗型的进程优先级，减少其时间片长度。<br>            这样用户体验能得到改善。<br>            不过这种微调，在CFS里面就不需要了。后面会解释。</p>
<p>那么，在调度的时候，其实只关心TASK_RUNNING状态下的进程。别的状态下的进程，不会被放到调度队列中去。<br>对于调度队列，这里面又分成两种状态。<br>一种是进程已经被调度到CPU上正在执行。<br>二是进程在队列中，正等待被调度执行。<br>那么，假设cpu有4核。需要执行的进程一共有8个。那么任何一瞬间，其实真正得到运行的进程，只有4个。另外4个则处于等待的状态。<br>所以说，系统当前同时进行调度的进程数，去除以cpu的核心数，这个比值，可以一定程度的反应系统繁忙的程度。<br>有关这个繁忙程度，有个概念是load average。<br>yandong@CH4WDT22X8DB2:~$ uptime<br> 16:44:29 up 45 days,  7:35,  9 users,  load average: 1.05, 0.70, 5.09</p>
<p>over the last 1 minute: The computer was overloaded by 5% on average. On average, .05 processes were waiting for the CPU. (1.05)</p>
<p>over the last 5 minutes: The CPU idled for 30% of the time. (0.70)</p>
<p>over the last 15 minutes: The computer was overloaded by 409% on average. On average, 4.09 processes were waiting for the CPU. (5.09)</p>
<p>O1算法大致有下面这些规则：<br>1.父进程fork出来的子进程，会和父进程平分其时间片。如果父进程原来是100ms.则fork以后，父进程和子进程各占50ms.<br>    这样做的原因是为了防止进程通过fork方式大量占有时间片。<br>2.TASK_RUNNING状态的进程。之前也提到，分为正在调度的和等待调度的。O1算法把这两种分类，分别对应到两个队列。<br>    一个队列是活动队列，也就是正在cpu上运行的。二是过期队列，这里面的进程时间片已耗尽，等待下一次执行。<br>3。考虑上面1的情况，父进程fork出来一个新的子进程。子进程获得一个时间片。子进程放入队列，等待调度到cpu执行。<br>    然后内核在每个tick（通常是100Hz也就是10ms周期）结束的时候，检查：<br>    是不是当前进程时间片耗尽？是不是有更高优先级的进程需要调度？<br>    如果是，则将当前进程状态终止，换成等待队列中优先级最高的进程来执行。<br>CFS算法：<br>2.6.23以后，O1算法就被CFS算法替换了。针对一般优先级的进程，CFS作为SCHED_OTHER的算法使用。<br>CFS就是完全公平调度的缩写。<br>那么如何实现完全公平的调度？<br>做法就是，当有n个进程在等待调度执行。调度器会在一个比较短的特定时间长度以内，把n个进程全部调度一遍，让他们都享用到cpu的时间。<br>这就是所谓的完全公平调度。<br>那么既然调度器在比较大的特定时间长度以内，会调用完所有的进度。<br>也就是说，RUNNING状态的进程，从一次调度到下一次，中间最大的延迟，就是这个时间。<br>这个时间被称为调度周期，也就是sched_latency_ns。<br>进程越多，在sched_latency_ns不变的情况下，每个进程分到的时间片就越小。<br>调度器只需要对所有进程维护一个累积占用CPU时间数，就可以衡量出每个进程目前占用的CPU时间总量是不是过大或者过小，<br>这个数字记录在每个进程的vruntime中。所有待执行进程都以vruntime为key放到一个由红黑树组成的队列中，每次被调度执行的进程，<br>都是这个红黑树的最左子树上的那个进程，即vruntime时间最少的进程，这样就保证了所有进程的相对公平。    （这段没怎么看懂）<br>但总之就是照顾公平，谁分配到的时间小，就调度谁。</p>
<p>调度的具体驱动机制如下：<br>1.tick时钟来的时候，会去调度队列检查是否需要调度。<br>2.当前进程状态发生转换时，比如退出或者休眠<br>3.除了休眠外，如果调用sched_yield()，在不发生进程状态变化的情况下，主动让出cpu。<br>4.当前进程的vruntime时间大于进程的理想占用时间delta_exec &gt; ideal_runtime。 ideal_runtime其实就是sched_latency_ns／进程数n。<br>    说白了就是你这个进程，占用的时间太多了，多于平均时间。<br>5.从中断/异常/系统调用返回，会发生调度检查。<br>相关API:<br>schedule()<br>作用是申请系统去发生调度。调度与否由内核决定，不是一定执行了就会被调度的。调度完成后回到原函数继续执行。<br>函数的关键结果是设置一个叫做next的变量，使它指向被选中的进程，该进程将取代当前进程。<br>如果系统中没有优先权高于当前进程的可运行进程，最终next与current相等，不发生任何进程切换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage void __sched schedule(void)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk = current;//current是当前进程</span><br><span class="line">	sched_submit_work(tsk);//说是避免死锁，具体原理待分析</span><br><span class="line">	__schedule();//这就是调度的主函数了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的流程分析，参见“schedule()函数（重点）.pdf”<br>cond_resched()<br>这个函数本质上还是schedule()，区别在于，相比普通的schedule()，会很快被调度回来，甚至立刻被调度回来。换言之，即把自己重新以抢占的形式调度回来。<br>如果执行后发生的调度，则返回1，否则返回0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define cond_resched() (&#123;			\</span><br><span class="line">	__might_sleep(__FILE__, __LINE__, 0);	\</span><br><span class="line">	_cond_resched();			\</span><br><span class="line">&#125;)</span><br><span class="line">int __sched _cond_resched(void)</span><br><span class="line">&#123;</span><br><span class="line">	if (should_resched()) &#123;</span><br><span class="line">		__cond_resched();</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __cond_resched(void)</span><br><span class="line">&#123;</span><br><span class="line">	add_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">	__schedule();</span><br><span class="line">	sub_preempt_count(PREEMPT_ACTIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PREEMPT_ACTIVE这个宏是抢占式内核里对优先级的一个计数而且是一个很大的计数，基本可以理解为：<br>把优先级提高。所以在重调度前，先将当前进程放到队列前列，这导致内核在重新调度时有很大的几率会优先把原进程调度回来。在回到调度点后再除去自身的优先级。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/28/位操作/" rel="next" title="位操作">
                <i class="fa fa-chevron-left"></i> 位操作
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/28/异步通知和异步IO/" rel="prev" title="异步通知和异步IO">
                异步通知和异步IO <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Semiyd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semiyd</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
