<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="内存管理">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="http://yoursite.com/2018/07/28/内存管理/index.html">
<meta property="og:site_name" content="Semiyd&#39;s Blog">
<meta property="og:description" content="内存管理">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-28T08:15:06.842Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="内存管理">
<meta name="twitter:description" content="内存管理">






  <link rel="canonical" href="http://yoursite.com/2018/07/28/内存管理/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>内存管理 | Semiyd's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Semiyd's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Semiyd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Semiyd's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">内存管理
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-28 15:21:12 / Modified: 16:15:06" itemprop="dateCreated datePublished" datetime="2018-07-28T15:21:12+08:00">2018-07-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/" itemprop="url" rel="index"><span itemprop="name">Kernel</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/内存管理/" itemprop="url" rel="index"><span itemprop="name">内存管理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><center><strong>内存管理</strong></center><br><a id="more"></a><br>====================================内存管理====================================================<br>linux内存管理的最小单位是页，而不是字节。页大小，也就是PAGE_SIZE常量，大部分体系架构包括ARM，都是4k.<br>内核和用户空间皆使用虚拟地址<br>内核有自己的地址空间<br>每个进程也有自己独立的地址空间<br>这些空间之间互不干涉</p>
<p>最基本的知识就是下面这些概念：<br>内核地址 物理地址 虚拟地址 总线地址 线性地址  逻辑地址<br>由最底层往上开始解释：</p>
<p>物理地址：Physical Address<br>    这个不用解释了。CPU地址总线上的寻址物理内存的地址。</p>
<p>总线地址:<br>    总线地址是从设备角度上看到的内存地址，物理地址是从CPU角度上看到的未经转换的内存地址(经过转换的那叫虚拟地址)<br>    由于有时候接口总线是通过桥接电路被连接，桥接电路会将IO地址映射为不同的物理地址。</p>
<p>线性地址：Linear Address        (x86概念)<br>    如果启用了分页机制，那么线性地址经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。</p>
<p>逻辑地址：Logical Address        (等于虚拟地址)<br>    例如，你在进行C语言指针编程中，可以读取指针变量本身值(&amp;操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。<br>    程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。<br>    上面三者的关系是：<br>    逻辑地址 —-（段表）—&gt; 线性地址 — （页表）—&gt; 物理地址    （x86架构的MMU的做法）<br>    不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映射到同一个物理地址上；所以是多对一的关系。<br>    另外，同一个线性地址，在发生换页以后，也可能被重新装载到另外一个物理地址上。所以这种多对一的映射关系也会随时间发生变化。</p>
<p>内核逻辑地址：<br>    是指内核虚拟地址中，低端内存也就是内核直接映射物理内存一个偏移量的区域。说白了就是低端内存区域。</p>
<p>虚拟地址：Virtual Address<br>    虚拟地址到物理地址的映射，是通过页表（page table）来实现的。<br>    映射本身由硬件（MMU）完成，但内核需要维护页表及其配置。<br>    虚拟地址包括内核空间的虚拟地址和用户空间的虚拟地址<br>    Linux系统中，4GB内存空间（0x00000000到0xFFFFFFFF）被划分成为两个部分——用户空间和内核空间，大小分别为0~3G，3~4G。<br>    用户进程通常情况下，只能访问用户空间的虚拟地址，不能访问到内核空间。<br>    内核地址空间由内核所有线程共享，但只有运行在内核态的线程才能访问.<br>    每个用户进程的用户空间都是完全独立、互不相干的，用户进程各自有不同的页表。而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。<br>    内核空间地址有自己对应的页表，内核的虚拟空间独立于其他程序。<br>    那么为什么不把所有的地址空间全部给内核，而是要分1G/3G的划分呢？<br>        主要原因还是要保证内核和用户进程的独立，不起冲突。</p>
<pre><code>下面分别介绍1G/3G这两个不同的内存空间：

3~4G之间的内核空间中（0xC0000000到0xFFFFFFFF），从低地址到高地址依次为：
    （以下针对的是x86架构）
    物理内存映射区/内核逻辑地址空间/低端内存映射区—隔离带—高端内存映射区/vmalloc虚拟内存分配区—专用页面映射区—保留区。    
    对于内核物理内存映射区的虚拟内存“低端内存”（用kmalloc(), __get_free_pages申请的），    
        使用__virt_to_phys()/__pa()和__phys_to_virt()/__va()来实现物理地址和内核虚拟地址之间的互相转换。(此方法仅适用于低端内存+DMA区域。也就是ARM架构中的常规内存+DMA区)
        一般转换出来就会发现就是一固定偏移而已。
    在系统初始化的时候，低端内存就永久映射到内核逻辑地址空间，也就是永久的建立好了固定的映射的页表。它实际上，仅仅做了PAGE_OFFSET大小的地址移位。
    PAGE_OFFSET=0xC0000000
    而类似vmalloc的“高端内存”的虚拟地址与物理地址之间不存在如此简单的换算关系。内核初始化过程不会为这段内存建页表。而是需要用高端内存的时候，才去建页表。
    高端内存是不能用__pa()或者__va()/__virt_to_phys()来转换虚拟地址和物理地址的!
    【内核空间虚拟内存动态申请】
    主要包括三个函数：kmalloc(), __get_free_pages(), vmalloc()。
    kmalloc(), __get_free_pages()申请的内存位于物理地址映射区，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因此存在较简单的转换关系。
    vmalloc()申请的内存位于vmalloc虚拟内存分配区（这些区都是以线性地址为度量）,这片连续的虚拟内存在物理内存中并不一定连续，
        而vmalloc申请的虚拟内存和物理内存之间也无简单换算关系。
        具体vmalloc怎么从虚拟到物理转换，就要查找页表了，操作比较复杂。
        同样的道理，如果是用户空间的malloc的地址，一样是只有通过查找页表才能得到物理地址。
        详见“内核管理实战之虚地址转换为物理地址.pdf”
    因为vmalloc()申请的在虚拟内存空间连续的内存区在物理内存中并不一定连续，可以想象为了完成vmalloc，新的页表需要被建立.
    因此，只是调用vmalloc来分配少量内存是不妥的。
    一般来讲，kmalloc用来分配小于128K的内存，而更大的内存块需要用vmalloc来实现。
    内核空间分配内存，有3种途径：
    1：kmalloc-&gt;SLAB allocator-&gt;Page allocator
    2：vmalloc-&gt;Page allocator
    3：SLAB allocator-&gt;Page allocator    通常由内核子系统例如directory entry,file object,network packet descriptor,process descriptor。驱动不太用到。
    这个Page allocator，通常cpu体系架构是4k每页，例如__get_free_page().__get_free_page()本身拿到的物理内存是连续的
    也就是说，内核空间，分配内存最终都是用的__get_free_page()这类页分配的API
    kmalloc可以分配小内存。如果需分配的内存较小，就从SLAB里面去取（最小粒度取决于SLAB的object大小）。如果分配的内存大，则直接从__get_free_page()里面去取内存页。
    vmalloc则分配以页为单位的内存。vmalloc会多次通过alloc_page()获取它所需要的页的个数，因为多次调用获取页的函数alloc_page()，导致可能不连续。（kernel/mm/vmalloc.c）
    另外再说下SLAB分配器。
        SLAB能创建内存cache池。在cache中，有很多大小相同的object。这个object本身的大小，可以比page小，或者大。
        SLAB根据实际的需求，或增大或者减小cache的总大小。
        系统对SLAB的使用情况，可以用命令：
        cat /proc/slabinfo查看
        SLAB的一个cache，里面可以有很多的页。每个页4k.但是object却可以很小，比如512字节或者1k字节。这样申请到4k的页以后，就可以以更小的粒度来分配给别人。
        具体的API，除了SLAB，还有SLUB和SLOB。后两者更新，性能更好些。
    不允许申请比1G更大的内存（如果配比是3~4G的话）
    不存在页错误，因为不存在页的换出

    高端内存进一步的解释：
    假设，一个系统的物理RAM大小，远小于1GB.比如说，是512MB.（见下面的“实际虚拟地址的布局举例”）
    low memory这段的范围是0xC0000000~high memory，大小规定等于物理内存大小。
    那么high memory~0xFFFFFFFF之间，还有足够的空间来映射一些I/O空间。（因为ioremap会映射到内核的vmalloc映射区域）
    那么。假如，一个系统的物理RAM大小，大于1GB.就没有足够的内核空间（最大1GB）来映射全部的物理内存+I/O空间了。怎么办？
    为了解决这个问题，x86平台取了一个经验值：896MB.就是说，假如一个系统的物理RAM，&gt;896MB的话，那么布局确定为如下：
    0xC0000000~896MB    这部分，是把物理内存的前896MB，作为物理内存映射区/内核逻辑地址空间/低端内存映射区的固定映射。
    而896MB~0xFFFFFFFF    这部分，则不再建立物理内存映射区/内核逻辑地址空间/低端内存映射区的固定映射。这部分内存，会被称为高端内存。一些I/O操作的空间，会放在这里。
                这部分也就是上面提到的高端内存映射区/vmalloc虚拟内存分配区
    简单的说，就是896MB这个值，给高端内存空间和I/O空间做了预留。如果大于896MB，那么低端内存不能再多了，需要预留一些给高端内存+I/O空间。
    如果需要比896MB更多的低端内存。要么改动1G/3G的比例，变成2G/2G.不过这样会导致用户进程的空间减小。要么换成64位系统(内核空间和用户空间各128TB)。
    这个896MB的经验值，每个CPU架构平台是不一样的。比如MIPS平台，就是设定512MB.
    那么对于MIPS，如果内存&lt;512MB，则内核直接无需配置CONFIG_HIGHMEM选项。
    那么对于ARM，是怎么样的情形？
        在物理内存小于xxxMB的情况下，无需开CONFIG_HIGHMEM。如果大于xxxMB，则需要开CONFIG_HIGHMEM才能让vmalloc能够使用更多的物理内存。
        不过在没有LPAE地址扩展的情况下，32位的系统，仍然不能寻址超过4GB（armv7-a架构，已支持LPAE，在开启MMU的情况下，可以支持40bit地址，寻址到1TB）
        ARM架构的highmem的界限到底是多大？                            
            arch\arm\mm\mmu.c    
            static void * __initdata vmalloc_min =
                (void *)(VMALLOC_END - (240 &lt;&lt; 20) - VMALLOC_OFFSET);
            也就是说。ARM的vmalloc区的最小大小，是240MB，而不是x86的128MB。
            所以ARM很可能是大于768MB，就要打开HIGHMEN了？
            参照一些超过1G RAM的ARM平台的实际的系统，可以看到，
            Virtual kernel memory layout:
                ...
              lowmem  : 0xc0000000 - 0xef800000   ( 760 MB)            arch/arm/include/asm/memory.h
            这个值就是760MB.超过760MB，就必须打开HIGHMEM了。
        am335x为例，其实HIGHMEM没开。此时把CONFIG_HIGHMEM打开，发现Virtual kernel memory layout基本没变，就多了行    pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)
    再回到896MB这个设定。对于x86平台，那么既然是896低端内存，就剩下了128MB的高端内存，也就是vmalloc部分的内存。
    vmalloc的大小可以在bootargs里面设置，默认128MB.
    这个128MB，也是x86平台，vmalloc的最小保留大小。见arch\x86\mm\pgtable_32.c的unsigned int __VMALLOC_RESERVE = 128 &lt;&lt; 20;
    那比如说，现在实际的物理内存是3G.前896MB是低端内存直接映射。假设是1G/3G的配比。那内核现在就只能在128MB的高端内存里面，去访问3G物理内存中没映射到低端内存的剩下部分。
    这是如何做到的呢？
    针对896MB的设定情形，在128MB也就是0xF8000000~0xFFFFFFFF这段地址，内核会根据vmalloc需要的大小，找个相同大小的空闲的地址空间，借用一会。
    也就是临时的建立映射（即填充内核PTE页面表），借用一会，用完后归还。所以32bit系统带HIGH_MEM的vmalloc有个限制，就是不能超128MB.
    内核把高端内存分为3部分：
    VMALLOC_START和VMALLOC_END        这部分就是vmalloc高端内存映射到的地方
    KMAP_BASE~FIXADDR_START        这部分是：通过alloc_page()或者高端内存的一个page，然后通过kmap()，把这个page映射到这部分的空间中。    又称永久映射
    FIXADDR_START~FIXADDR_TOP        这部分通过kmap_atomic()调用fix_to_virt()实现临时映射。                        又称临时映射
    那么高端内存，由于是内核无法寻址所有物理内存的产物。所以其实64bit的内核，并不存在高端内存。因为64bit的内核可以支持寻址超过512GB的物理内存。    
    注意，即使没有highmem，仍然存在大段的vmalloc空间。这对物理内存不连续的时候，需要分配连续的虚拟地址的内存是很重要的。

    （以下针对32bit ARM架构）
    内核模块映射区-高端内存—DMA区域-常规内存区域—隔离带—vmalloc虚拟内存分配区—隔离带—向量表
    这里有关DMA区域。因为有些ARM的DMA，寻址范围有限。如果说DMA寻找范围有限（例如只能寻址32MB），则DMA区域就是32MB，剩下就是常规内存区域。
    如果DMA寻址无限制，则DMA和常规内存区域就没有界限了，两者就是同一个东西。    

0~3G之间的用户空间中（0x00000000到0xBFFFFFFF）每个进程都有一个独立的3GB用户空间，所以用户空间由每个进程独有。
    虽然每个进程都有很大的地址空间。但只有真正用到的页，才会被MMU分配到物理内存上。
    所以每个进程都有4GB地址空间(注意是4G,1G+3G中，1G也算是进程的，只是这个空间是内核空间，进程要系统调用才能访问)，但实际上只有其中的小部分用到的才被真正对应到物理内存上。    
    允许用户申请比实际物理RAM更大的内存。（&gt;3G）
    所有进程真正使用的内存，有可能超过实际的物理内存大小，此时需要通过linux的swap过程，把不太常用的页，换到比如硬盘上，把需要用的也，从硬盘上换到物理RAM上去。
    这个过程用到的算法，被称为page-replacement algorithm，具体的例子比如least recently used算法。
    现在的内核swap是可以分优先级的。比如SSD上的swap去被设为高优先级，先用尽SSD，然后硬盘上的swap区被设为低优先级，SSD用完再用硬盘。
    内核空间的页不会被交换出去。只有用户空间的页会被交换出去。当然用户空间的页也可以通过mblock来锁定页，不让它被swap交换出去。
    当一个内存被请求使用时，如果这个页不在MMU当前的映射里面（可能已经被swap到硬盘上去了），则会触发一个page fault中断，被MMU察觉。
    一些相关的问题解释：
    1.对于32bit的内核，每个用户进程都有各自独立的4G寻址空间。怎么保证一个进程访问虚拟地址的某个地址的时候，不和别的进程的虚拟地址相混淆呢？
        每个进程都有自身的页面目录PGD。内核将该目录的指针，存放在与进程对应的内存结构task_struct{}.mm.pgd中。(也就是说PGD是内核空间的数据，因为task_struct{}就是内核的)
        所以每次进程被schedule()进入运行态的时候，内核都要把该进程的PGD指针设置给CR3控制寄存器（通过switchmm()）.设置了CR3，指向当前页面的指针变了,MMU就是根据
        新的页面转换地址了。
        当然，因为PGD指针是内核空间的数据结构，属于内核的低端内存的虚拟地址。而CR3寄存器要的是物理地址。所以真正要写到CR3之前，要用__pa()转换成物理地址再写。
    2.每个进程的PGD，也就是页面目录，分成两部分。一部分是3G的用户空间，一部分是1G的内核空间。3G的用户空间每个进程是独立的。
        而1G的内核空间，所有进程都是相同的，也就是内核使用的那个1G空间。
    正常情况下，只能访问3G空间。只有通过system_call()进入内核态，才能访问那个1G的内核空间。
        另外，在进程进入内核态的时候，和进程切换不同，不改变CR3（因为每个进程的PGD本身就已包含1G内核空间的映射），只是改变堆栈。也就是从进程的堆栈，切换到内核堆栈。



AM3354实际虚拟地址的布局举例解析：    (CONFIG_HIGHMEM=NO)    
Memory: 509380k/509380k available, 14908k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)            
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)            
    vmalloc : 0xe0800000 - 0xff000000   ( 488 MB)        在低端内存末尾0xe0000000 基础上加8MB隔离带(#define VMALLOC_OFFSET     (8*1024*1024))，也就是0xe0800000
    lowmem  : 0xc0000000 - 0xe0000000   ( 512 MB)
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .text : 0xc0008000 - 0xc07e1000   (8036 kB)
      .init : 0xc07e1000 - 0xc087b000   ( 616 kB)
      .data : 0xc087c000 - 0xc08dd060   ( 389 kB)
       .bss : 0xc08dd084 - 0xc0a204f8   (1294 kB)
上面的布局解释如下：
1.am335x的CONFIG_HIGHMEM并没有打开
2.vector  : 0xffff0000 - 0xffff1000   (   4 kB)            表示ARM的向量表固定映射到0xffff0000
3.fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)            表示在arch/arm/include/asm/fixmap.h固定写好的范围.用来给boot阶段映射固定的硬件地址等。
                            定义于arch/arm/include/asm/fixmap.h
                            #define FIXADDR_START        0xfff00000UL
                            #define FIXADDR_TOP        0xfffe0000UL
4.vmalloc : 0xe0800000 - 0xff000000   ( 488 MB)        表示在低端内存末尾0xe0000000 基础上加8MB隔离带(#define VMALLOC_OFFSET     (8*1024*1024))，也就是0xe0800000
                            另外，根据arch\arm\include\asm\pgtable.h里面#define VMALLOC_END        0xff000000UL
                            #define VMALLOC_START        (((unsigned long)high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1))
                            所以VMALLOC区，从物理内存结束开始，加8MB开始，也就是0xe0800000。然后到VMALLOC_END也就是0xff000000结束
                            注意，即使没有highmem，仍然存在大段的vmalloc空间。这对物理内存不连续的时候，需要分配连续的虚拟地址的内存是很重要的。
5.lowmem  : 0xc0000000 - 0xe0000000   ( 512 MB)        表示低端内存区，大小和物理内存一样。

上面的设置是：Memory split (3G/1G user/kernel split)  ---&gt;。如果设成2G/2G的，则变成：
    Virtual kernel memory layout:
        vector  : 0xffff0000 - 0xffff1000   (   4 kB)
        fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
        vmalloc : 0xa0800000 - 0xff000000   (1512 MB)    注意到这边vmalloc充满了剩余的2G内核空间.
        lowmem  : 0x80000000 - 0xa0000000   ( 512 MB)
        modules : 0x7f000000 - 0x80000000   (  16 MB)
          .text : 0x80008000 - 0x807e0000   (8032 kB)
          .init : 0x807e0000 - 0x8087a000   ( 616 kB)
          .data : 0x8087a000 - 0x808dac60   ( 388 kB)
          .bss : 0x808dac84 - 0x80a1e0f8   (1294 kB)
</code></pre><p>虚拟地址 逻辑地址 线性地址    的关系是？<br>    首先逻辑地址=虚拟地址<br>    在linux中，不再专门分段，只是分页。所以逻辑地址=虚拟地址=线性地址。</p>
<p>参考资料：<br>C:\Document\Document\Linux\Kernel\学习资料\User space memory access from the Linux kernel.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\我理解的逻辑地址、线性地址、物理地址和虚拟地址.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\虚拟地址转物理地址.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\linux内存管理.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\malloc实现原理.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\Linux驱动虚拟地址和物理地址的映射.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\How does ioremap convert physical address to virtual address.pdf        此文解释了物理地址映射到虚拟地址的过程<br>C:\Document\Document\Linux\Kernel\学习资料\free-electrons.com系列资料\Linux kernel and driver development course\linux-kernel-slides.pdf    page249有关内存管理的部分<br>C:\Document\Document\Linux\Kernel\学习资料\Linux设备驱动程序学习（20）-内存映射和DMA-基本概念.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\Linux设备驱动程序学习（21）-内存映射和DMA-数据结构.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\Virtual Memory I the problem [LWN_net].pdf<br>C:\Document\Document\Linux\Kernel\学习资料\kmalloc and vmalloc  Linux kernel memory allocation API Limits.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\内存泄漏检测kmemleak示例.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\Linux内核高-低端内存设置代码跟踪（ARM构架）.pdf<br>Documentation\vm\highmem.txt<br>Documentation\arm\memory.txt<br>C:\Document\Document\Linux\Kernel\学习资料\Linux用户空间与内核空间（理解高端内存）.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\linux内核的high memory概念详解.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\我所理解的high memory.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\linux arm vmalloc详解.pdf<br>C:\Document\Document\Linux\Kernel\学习资料\linux support for ARM LPAE.pdf    有关ARM LPAE的内容在这<br>C:\Document\Document\Linux\Kernel\学习资料\arm mm memory layout.pdf        有关如何调整vmalloc区，遇到有空洞的bank怎么办，参考这篇文章<br>========================================内存分配和映射===================================================<br>内存分配：<br>    malloc:<br>        用于用户空间的分配。大小无限制。<br>    kmalloc：<br>        用于内核空间的物理连续地址分配。<br>            具体参数的使用：(所谓GFP_打头的参数，就是<strong>get_free_pages的首字母缩写，因为kmalloc内部是依赖于</strong>get_free_pages的)<br>            可以睡眠，分配失败就睡眠                     GFP_KERNEL<br>            可用于中断上下文，不可以睡眠，分配失败就放弃      GFP_ATOMIC<br>            软中断                    GFP_ATOMIC<br>            Tasklet                    GFP_ATOMIC<br>            用于DMA的内存        GFP_DMA    此标志能够保证是在dma_mask有效范围内的内存地址里面去分配<br>            用于DMA的内存，可以睡眠      GFP_DMA | GFP_KERNEL<br>            用于DMA的内存，不可以睡眠     GFP_DMA |GFP_ATOMIC<br>            还有些不常用的标志包括：<br>            用于为用户空间页分配内存，会阻塞    GFP_USER<br>            不允许任何IO初始化    GFP_NOIO<br>            不允许进行任何文件系统调用    GFP_NOFS<br>            指定高端内存来分配    GFP_HIGHMEM<br>            请求一个较长时间不访问的页    <strong>GFP_COLD<br>            高优先级的请求，允许获得内核保留的紧急情况才能用的页    </strong>GFP_HIGH    </p>
<pre><code>        GFP_KERNEL 会引起休眠的原因是，系统空闲内存不够分配的时候，会把当前申请内存的进程转入休眠以等待空闲的页面
        GFP_ATOMIC不会休眠的原因是，内核通常会原子性的预留一些空闲的页面，使用GFP_ATOMIC标志时，
        kmalloc()甚至可以用掉最后一个空闲页面，当最后一个空闲页面也没有时，分配就会失败
    物理地址的连续对DMA有用
    kmalloc分配的大小有1GB限制
    分配到的地址是逻辑地址（也属于虚拟地址），和物理地址只有一个固定偏移
    变种：kzalloc()，分配并清零分配到的数据
vmalloc：
    用于内核空间的大内存的地址分配。物理地址不一定连续（所以不能用于DMA），分配速度比kmalloc慢。
    可能睡眠，不能用于中断上下文
    分配到的地址是虚拟地址，和物理地址由页表映射，无直接对应关系。原因是每次vmalloc，都要建立页表。
look aside buffers：
slabs：
    kmalloc分配小内存就基于slab
    典型的API包括：
    kmem_cache_alloc()
    kmem_cache_free()
    kmem_cache_destroy()（摧毁整个内存池）
    在/proc/slabinfo下，能看到当前slab的分配和使用情况。
mempools：
    顾名思义，其实就是内存池。和slab一样，这也是一种内存池的概念。
    API包括：
    mempool_create()        创建内存池
    mempool_alloc()        从内存池中分配内存
    mempool_free()        把内存回收到内存池中
    mempool_destroy()    摧毁内存池

kmemdup:
    根据给定的一段地址区间，再分配一个内存空间，将原地址空间的内容拷贝到新分配的内存空间中。
kmemleak:
    检查内存泄漏情况，适用于各个cpu体系架构。
    参见：C:\Document\Document\Linux\Kernel\学习资料\内存泄漏检测kmemleak示例.pdf
</code></pre><p>内存映射：<br>    ioremap:        （用来访问cpu的寄存器地址）<br>        cpu的寄存器地址，分为两种。<br>            I/O-mapped：<br>                x86架构，为外设专门实现了一个单独的地址空间，称为”I/O地址空间”或者”I/O端口空间”，CPU通过专门的I/O指令（如X86的IN和OUT指令）来访问这一空间中的地址单元。<br>            Memory-mapped<br>                ARM等RISC架构，只实现一个物理地址空间，外设I/O端口成为内存的一部分。<br>                此时，CPU可以象访问一个内存单元那样访问外设I/O端口，而不需要设立专门的外设I/O指令。<br>        返回的是虚拟地址，和vmalloc一样的，也需要新建页表。<br>        但是和vmalloc不同的是，ioremap并不实际分配内存，而是通过建立页表将设备寄存器地址映射到内核虚拟地址空间(位于内核的vmalloc映射区域).<br>        返回的地址不能直接使用，需要通过专用的<strong>raw_writel()，</strong>raw_readl()来访问（为了保证驱动跨平台的可移植性）<br>        通过ioremap()获得的虚拟地址应该被iounmap()函数释放<br>        devm_ioremap()的作用一样是无需在退出的时候，执行iounmap()。<br>    request_mem_region:<br>        这个函数是和ioremap配对一起使用的。<br>        用法就是先request_mem_region进行申请，在申请完成后再用ioremap进行映射。<br>        request_mem_region成功的话，会返回一个非NULL指针，并且cat /proc/iomem能看到分配的I/O。<br>        其他的变种有：<br>        check_mem_region()宏，检查指定的I/O内存资源是否已被占用。<br>        release_mem_region()宏，释放指定的I/O内存资源。<br>    phys_to_virt<br>        从物理地址然后加一个固定的偏移得到虚拟地址。<br>    mmap<br>        mmap映射一个设备，意味着使用户空间的一段地址关联到外设内存上<br>        这使得只要程序在分配的地址范围内进行读取或者写入，实际上就是对设备的访问。<br>        这种数据传输是直接的，不需要用到内核空间作为数据转移的中间站。<br>    unsigned int <strong>get_free_pages(unsigned int gfp_mask, unsigned int order)<br>        该函数是基于页的分配函数，因此在分配整数页内存并且物理地址必须连续的时候<br>        使用面向页的分配技术会更好些，这样会减少内存碎片的出现，该函数分配若干物理内存连续的页面，返回值是该内存区第一个页的逻辑地址.<br>        内存页释放函数如下：<br>        void free_pages(unsignedlong addr, unsigned long order)<br>            释放页时要谨慎，只能释放属于你的页，传递错误的地址或者错误的order值，都可能导致系统崩溃.<br>    readb/readw/readl和writeb/writew/writel<br>        刚刚提到的ioremap的地址，是需要用以上这些API来访问的。不要用直接指针的方式访问，用这个更安全。<br>        b对应字节，w对应word双字节，l对应四字节。<br>        因为arm是32位的多。所以一般都用readl和writel。<br>        代码举例：writel其实就是比</strong>raw_writel多了个内存屏障。<br>        void writel(u32 b, volatile void <strong>iomem *addr)<br>        {
            </strong>raw_writel(b, addr);<br>            mb();<br>        }</p>
<p>参考资料：</p>
<h1 id="http-blog-chinaunix-net-uid-27717694-id-4333971-html"><a href="#http-blog-chinaunix-net-uid-27717694-id-4333971-html" class="headerlink" title="http://blog.chinaunix.net/uid-27717694-id-4333971.html"></a><a href="http://blog.chinaunix.net/uid-27717694-id-4333971.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-27717694-id-4333971.html</a></h1><p>========================================内核和MMU===================================================<br>MMU有三个主要的作用：<br>1.重定位：就是换入换出的概念，解决物理内存的不足问题。<br>2.保护：保护进程间内存不互相破坏，并且保护内核代码不受应用程序破坏<br>3.共享：实现不同进程的内存共享，还有内核和应用之间的内存共享。</p>
<p>要实现MMU的以上的功能，比如在物理内存中告诉MMU映射信息<br>页表就是包含这种信息的数据结构。它是一个多级树形数组，包含了虚拟地址到物理地址的映射信息，还有一些关联的标志位。<br>页表具体的数据结构，根据不同的体系架构有所不同。因为页表是直接提供给MMU单元去读取的。不同的架构的MMU不同，所以提供给MMU识别的数据结构是不同的。</p>
<p>linux使用MMU的大致过程如下：<br>1.cpu上电默认是关闭MMU的。<br>2.u-boot成功引导kernel后，kernel会在物理内存中初始化页表。之后将页表的入口的物理地址告诉MMU。<br>3.启动MMU<br>4.此后就是用的都是虚拟地址了。具体地址转换的过程，就是MMU通过CR3控制寄存器的值，作为当前页面的指针，进而根据分页内存映射机制，把地址进行转换。</p>
<p>MMU的两个基本概念：<br>1.TLB=translation lookaside buffer.也就是转换旁路缓存。这个是MMU的核心部件，里面缓存少量的虚拟地址和物理地址的转换关系，是转换表的cache，因此常被成为快表。<br>2.TTW=translation table walk，也就是转换表漫游。说白了就是，如果当前所需要的虚拟地址和物理地址的转换，再TLB这个缓存中没找到，则需要执行TTW的动作。<br>    也就是遍历整个页表。当然大多数cpu会有多级页表。<br>    较新的linux内核，有4级页表：PGD,PUD,PMD,PTE。</p>
<p>通过MMU进行内存访问的流程，可以参见”ARM CPU访问内存地址的流程.jpg”</p>
<p>======================================页表=======================================================<br>较新的linux内核，有4级页表：PGD,PUD,PMD,PTE。<br>每个用户进程各自有不同的页表。<br>而内核的页表，其实只有一个，且是不变的。</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/28/并发和竞态/" rel="next" title="并发和竞态">
                <i class="fa fa-chevron-left"></i> 并发和竞态
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/28/内核空间和用户空间交换数据的API/" rel="prev" title="内核空间和用户空间交换数据的API">
                内核空间和用户空间交换数据的API <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Semiyd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#http-blog-chinaunix-net-uid-27717694-id-4333971-html"><span class="nav-number">1.</span> <span class="nav-text">http://blog.chinaunix.net/uid-27717694-id-4333971.html</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semiyd</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
