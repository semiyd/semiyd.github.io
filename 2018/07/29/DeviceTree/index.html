<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="DeviceTree">
<meta property="og:type" content="article">
<meta property="og:title" content="DeviceTree">
<meta property="og:url" content="http://yoursite.com/2018/07/29/DeviceTree/index.html">
<meta property="og:site_name" content="Semiyd&#39;s Blog">
<meta property="og:description" content="DeviceTree">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2021-03-21T07:45:15.247Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DeviceTree">
<meta name="twitter:description" content="DeviceTree">






  <link rel="canonical" href="http://yoursite.com/2018/07/29/DeviceTree/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>DeviceTree | Semiyd's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Semiyd's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/29/DeviceTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Semiyd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Semiyd's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">DeviceTree
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-29 09:10:33" itemprop="dateCreated datePublished" datetime="2018-07-29T09:10:33+08:00">2018-07-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2021-03-21 15:45:15" itemprop="dateModified" datetime="2021-03-21T15:45:15+08:00">2021-03-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/" itemprop="url" rel="index"><span itemprop="name">Kernel</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/驱动/" itemprop="url" rel="index"><span itemprop="name">驱动</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/Kernel/驱动/DeviceTree/" itemprop="url" rel="index"><span itemprop="name">DeviceTree</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><center><strong>DeviceTree</strong></center><br><a id="more"></a><br>总体上说，dts就是一份配置表<br>至于这个表，和具体kernel代码里面的联系，由下面这类字段完成：<br>compatible = “ti,tilcdc,panel”;<br>上面这个dts的字段，其实搜ti,tilcdc,panel，可以在kernel里面对应的驱动搜到一样的字段(用of_device_id结构体注册过同样的字段)。<br>这种compatible匹配的情况，kernel的驱动就可以例如调用probe函数，然后根据dts里面的配置完成具体的初始化工作(dts相当于以前的platform_device)<br>在drivers/下面的kernel驱动文件夹里，在原有的老文件内部，增加了很多叫of_xxx.c的驱动文件，就是专门来解析dts的。</p>
<p>==================device tree涉及的驱动层部分===========================<br>The compatible string used to bind a device with the driver<br>static struct of_device_id mxs_auart_dt_ids[] = {<br>{<br>.compatible = “fsl,imx28-auart”,<br>.data = &amp;mxs_auart_devtype[IMX28_AUART]<br>}, {<br>.compatible = “fsl,imx23-auart”,<br>.data = &amp;mxs_auart_devtype[IMX23_AUART]<br>}, { /<em> sentinel </em>/ }<br>};<br>MODULE_DEVICE_TABLE(of, mxs_auart_dt_ids);<br>[…]<br>static struct platform_driver mxs_auart_driver = {<br>.probe = mxs_auart_probe,<br>.remove = mxs_auart_remove,<br>.driver = {<br>.name = “mxs-auart”,<br>.of_match_table = mxs_auart_dt_ids,<br>},<br>};<br>Code from drivers/tty/serial/mxs-auart.c</p>
<p>of_match_device allows to get the matching entry in the<br>mxs_auart_dt_ids table.<br>I Useful to get the driver-specific data field, typically used to<br>alter the behavior of the driver depending on the variant of<br>the detected device.<br>static int mxs_auart_probe(struct platform_device <em>pdev)<br>{<br>const struct of_device_id </em>of_id =<br>of_match_device(mxs_auart_dt_ids, &amp;pdev-&gt;dev);<br>if (of_id) {<br>/<em> Use of_id-&gt;data here </em>/<br>[…]<br>}<br>[…]<br>}</p>
<p>dts文件顶层的compatible 属性，在代码里面的对应：<br>static const char *mxs_dt_compat[] __initdata = {<br>“fsl,imx28”,<br>“fsl,imx23”,<br>NULL,<br>};<br>DT_MACHINE_START(MXS, “Freescale MXS (Device Tree)”)<br>.dt_compat = mxs_dt_compat,<br>[…]<br>MACHINE_END<br>此时device tree顶层的compatible属性如下面的例子：<br>/ {<br>model = “Freescale i.MX28 Evaluation Kit”;<br>compatible = “fsl,imx28-evk”, “fsl,imx28”;<br>之前machine_is_xxx()接口，现在变成了of_machine_is_compatible(“fsl,imx28-evk”)这种接口，用来判断machine</p>
<p>==================device tree涉及的驱动层部分===========================</p>
<p>=======================bindings的概念===============================<br>所谓的bindings，就是指有哪些properties，这些properties有哪些 values<br>哪些properties是mandatory或者是optional，等等这类的信息，也就是描述device tree如何配置的细节</p>
<p>所有相关的文档目录都在：Documentation/devicetree/bindings/</p>
<p>里面有怎样配置具体的某个mcu的device tree的文档。</p>
<p>When creating a new device tree representation for a device, a<br>binding should be created that fully describes the<br>required properties and value of the device.<br>========================bindings的概念=============================<br>========================bus属性=============================<br>bus通常用来描述</p>
<p>举例：<br>apbh@80000000 {<br>    compatible = “simple-bus”;</p>
<pre><code>#address-cells = &lt;1&gt;;
#size-cells = &lt;1&gt;;
reg = &lt;0x80000000 0x3c900&gt;;
ranges;
[...]
hsadc: hsadc@80002000 {
    reg = &lt;0x80002000 0x2000&gt;;
    interrupts = &lt;13&gt;;
    dmas = &lt;&amp;dma_apbh 12&gt;;
    dma-names = &quot;rx&quot;;
    status = &quot;disabled&quot;;
};
[...]
</code></pre><p>};</p>
<p>compatible属性：<br>    定义总线的控制器，例如I2C, SPI, PCI,<br>    例子中是simple-bus，也就是不需要特别的驱动的和内存直接映射的总线</p>
<p>什么叫cells？<br>    是“属性”的一种。<br>    就是一个32bit unsigned integers，用尖括号表示。例如#size-cells = <1><br>    “属性”除了cell，其实还有：<br>    text string或者string list，用双引号表示。例如device_type = “memory”<br>    binary data，用方括号表示。例如binary-property = [0x01 0x23 0x45 0x67]<br>    所以，后面要介绍的#address-cells，#size-cells，都属于cells这种属性。</1></p>
<p>#address-cells属性：<br>    表示下面的子节点的reg属性里面，有几个地址的属性。<br>    例如#address-cells = <1>;，就是1个地址。<br>    注意，这个地址的值，可以是直接内存映射出来的cpu可以访问的内存地址。比如是cpu的串口控制器的地址，例如0x101f0000这种内存地址。<br>    也可以是某个i2c/spi的值，比如i2c的地址字节，spi的cs号，也就是虽然不能直接内存地址访问，但是仍然用来寻址的这类值。<br>    统称为address。<br>    最简单的例子就是cpus结点：<br>        cpus {</1></p>
<pre><code>    #address-cells = &lt;1&gt;;
    #size-cells = &lt;0&gt;;
    cpu@0 {
        compatible = &quot;arm,cortex-a9&quot;;
        reg = &lt;0&gt;;
    };
    cpu@1 {
        compatible = &quot;arm,cortex-a9&quot;;
        reg = &lt;1&gt;;
    };
};
</code></pre><p>#size-cells属性：<br>    表示下面的子节点的reg属性里面，每个地址的属性，有多大的地址范围大小（如果地址存在范围的概念的话，比如直接内存映射出来的cpu的某个以太网控制器的寄存器地址，就是一段范围）<br>    例如：<br>    / {            这个称为root node，根结点</p>
<pre><code>    #address-cells = &lt;1&gt;;
    #size-cells = &lt;1&gt;;

    ...

    serial@101f0000 {
        compatible = &quot;arm,pl011&quot;;
        reg = &lt;0x101f0000 0x1000 &gt;;        可见这个串口控制器的地址的范围大小是0x1000
    };
当然，如果是i2c设备，就没有size-cells这个属性了，因为i2c的地址其实就是地址字节，不存在范围多少的问题。
如下：
        i2c@1,0 {
            compatible = &quot;acme,a1234-i2c-bus&quot;;
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            reg = &lt;1 0 0x1000&gt;;
            rtc@58 {
                compatible = &quot;maxim,ds1338&quot;;
                reg = &lt;58&gt;;
            };
        };
</code></pre><p>reg属性<br>    表示子节点里面，#address-cells和#size-cells具体是多少。<br>    这个reg的值，在kernel里面，是可以通过of_xxx这种API，去获取的，从而被驱动程序引用到。</p>
<p>再举例：<br>    external-bus {</p>
<pre><code>    #address-cells = &lt;2&gt;;
    #size-cells = &lt;1&gt;;

    ethernet@0,0 {
        compatible = &quot;smc,smc91c111&quot;;
        reg = &lt;0 0 0x1000&gt;;
    };

    i2c@1,0 {
        compatible = &quot;acme,a1234-i2c-bus&quot;;
        reg = &lt;1 0 0x1000&gt;;
        rtc@58 {
            compatible = &quot;maxim,ds1338&quot;;
        };
    };

    flash@2,0 {
        compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;
        reg = &lt;2 0 0x4000000&gt;;
    };
};
</code></pre><p>这个例子，external-bus的子节点，都有2个地址属性。其作用是：（举例子而已）<br>&lt;片选号  偏移量    地址范围&gt;<br>上面这个“片选号”是人为的设定，你可以自定义这个地址真正的作用，最终完全取决于内核代码里面是如何使用这些地址的值的。</p>
<p>ranges属性：<br>    那么ranges又是什么东西？<br>    其实ranges是指，不同地址空间之间的转换关系。<br>    是这样的。对dts而言，首先，它有个root node，也就是根节点。根节点描述的是从CPU的视角来观察的地址空间。也就是那些内存地址，例如serial@101f0000的0x101f0000<br>    那么默认，根节点的第一级子节点，都是可以直接使用cpu的地址空间的。最简单的例子如下：<br>    / {        这个称为root node，根结点<br>        intc: interrupt-controller@00a01000 {        根节点的第一级子节点，直接使用cpu的地址空间，也就是00a01000<br>            compatible = “arm,cortex-a7-gic”;</p>
<pre><code>        #interrupt-cells = &lt;3&gt;;
        interrupt-controller;
        reg = &lt;0x00a01000 0x1000&gt;,
              &lt;0x00a02000 0x100&gt;;
    };
那么现在再看一个例子，就是根节点下面的二级子节点，里面有些地址信息。但是这些地址信息，其实是可以直接翻译/对应到CPU的内存地址空间的。这时候就用ranges翻译下：
</code></pre><p>/dts-v1/;</p>
<p>/ {        这个称为root node，根结点<br>    compatible = “acme,coyotes-revenge”;</p>
<pre><code>#address-cells = &lt;1&gt;;
#size-cells = &lt;1&gt;;
...
external-bus {        根节点的第一级子节点
    #address-cells = &lt;2&gt;
    #size-cells = &lt;1&gt;;
    ranges = &lt;0 0  0x10100000   0x10000     // Chipselect 1, Ethernet    表示类似&lt;0 0这种地址，能对应到CPU的内存地址空间是0x10100000  ，范围大小是0x10000     
              1 0  0x10160000   0x10000     // Chipselect 2, i2c controller    表示类似&lt;1 0这种地址，能对应到CPU的内存地址空间是0x10160000   ，范围大小是0x10000     
              2 0  0x30000000   0x1000000&gt;; // Chipselect 3, NOR Flash    表示类似&lt;2 0这种地址，能对应到CPU的内存地址空间是0x30000000   ，范围大小是0x1000000

    ethernet@0,0 {        根节点的第二级子节点，使用的地址是类似&lt;0 0 0x1000&gt;;这种形式
        compatible = &quot;smc,smc91c111&quot;;
        reg = &lt;0 0 0x1000&gt;;
    };

    i2c@1,0 {
        compatible = &quot;acme,a1234-i2c-bus&quot;;
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        reg = &lt;1 0 0x1000&gt;;
        rtc@58 {
            compatible = &quot;maxim,ds1338&quot;;
            reg = &lt;58&gt;;
        };
    };

    flash@2,0 {
        compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;
        reg = &lt;2 0 0x4000000&gt;;
    };
};
</code></pre><p>};<br>    也就是说，这个第二级的子节点，虽然用的是不同的地址空间，但其实可以翻译/对应到CPU的地址空间。具体怎么对应，看ranges的值即可。</p>
<pre><code>那么还有一种情况，就是ranges;这么一写，没有具体内容。意思是，子节点和父节点，内存的映射，是1:1的，不存在翻译的过程。举例如下：
</code></pre><p>/ {<br>    soc {        根节点的第一级子节点</p>
<pre><code>#address-cells = &lt;1&gt;;
#size-cells = &lt;1&gt;;
compatible = &quot;simple-bus&quot;;
interrupt-parent = &lt;&amp;gpc&gt;;
ranges;            表示其子节点，都是1:1映射使用CPU的内存地址空间的

caam_sm: caam-sm@00100000 {            果然，直接写了CPU的内存地址空间的地址0x00100000
    compatible = &quot;fsl,imx7d-caam-sm&quot;, &quot;fsl,imx6q-caam-sm&quot;;
    reg = &lt;0x00100000 0x3fff&gt;;        果然，直接写了CPU的内存地址空间的地址0x00100000
};

ocram: sram@00905000 {
    compatible = &quot;mmio-sram&quot;;
    reg = &lt;0x00905000 0x1B000&gt;;
};
 };
</code></pre><p>};</p>
<pre><code>还有种情况，就是根本不写ranges。这种情况最典型的就是i2c的子节点。i2c结点一般都代表i2c主控，子节点代表i2c的从设备的i2c driver。
    i2c@1,0 {
        compatible = &quot;acme,a1234-i2c-bus&quot;;
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        reg = &lt;1 0 0x1000&gt;;
        rtc@58 {
            compatible = &quot;maxim,ds1338&quot;;
            reg = &lt;58&gt;;
        };
    };
因为i2c的地址，没法直接对应到cpu的内存地址空间，所以可以不写ranges。


那么唠叨了半天，到底要ranges何用？
主要原因是这样，有些设备，使用了和cpu内存地址完全不同的地址空间的同时，它又是可以映射到cpu的内存地址空间的。例如：
PCI设备的地址
DMA
</code></pre><p>编译错误分析：</p>
<pre><code>spi { compatible = &quot;spi-gpio&quot;;
    #address-cells = &lt;0x1&gt;;
    ranges;
    gpio-sck = &lt;&amp;gpio 95 0&gt;;
    gpio-miso = &lt;&amp;gpio 98 0&gt;;
    gpio-mosi = &lt;&amp;gpio 97 0&gt;;
    cs-gpios = &lt;&amp;gpio 125 0&gt;;
    num-chipselects = &lt;1&gt;;
    /* clients */ 
    gpio_spi: gpio_spi@0 {
        compatible = &quot;fairchild,74hc595&quot;;
        gpio-controller;                    //Marks the device node as a gpio controller.
        #gpio-cells = &lt;2&gt;;                //Should be two.  The first cell is the pin number and the second cell is used to specify the gpio polarity:
        reg = &lt;0&gt;;                        //chip select number
        registers-number = &lt;2&gt;;            //Number of daisy-chained shift registers
        spi-max-frequency = &lt;10000&gt;;
        spi-cs-high;
        spi-cpol;
    };
};
编译出错：                            
Warning (reg_format): &quot;reg&quot; property in /spi-gpio/gpio_spi@0 has invalid length (4 bytes) (#address-cells == 1, #size-cells == 1)
Warning (avoid_default_addr_size): Relying on default #size-cells value for /spi-gpio/gpio_spi@0
其实是因为，没去标明#size-cells 的大小，导致后续检查reg的时候，编译器迷惑了，觉得reg写的格式不对
改成        
spi { compatible = &quot;spi-gpio&quot;;
    #address-cells = &lt;0x1&gt;;
    #size-cells = &lt;0&gt;;
就可以编译通过了
</code></pre><p>========================bus属性=============================<br>========================Interrupt和gpio属性=============================<br>举例：<br>1.预先定义的东西：<br>arch/arm/boot/dts/am33xx.dtsi：<br>        //定义总的中断控制器<br>        intc: interrupt-controller@48200000 {<br>            compatible = “ti,am33xx-intc”;<br>            interrupt-controller;</p>
<pre><code>    #interrupt-cells = &lt;1&gt;;        这个表示中断的具体格式的数目，比如interrupts = &lt;0 8 IRQ_TYPE_LEVEL_HIGH&gt;;，包含3个元素。所以就等于3.这里是&lt;1&gt;，表示就填一个字
    reg = &lt;0x48200000 0x1000&gt;;
};
//定义lcd控制器（仅仅示例看看别的dtsi节点是如何引用intc节点的）
lcdc: lcdc@4830e000 {
    compatible = &quot;ti,am33xx-tilcdc&quot;;
    reg = &lt;0x4830e000 0x1000&gt;;
    interrupt-parent = &lt;&amp;intc&gt;;        表明父类是继承的intc，所以下面那行#interrupt-cells的格式也要符合父类的intc，也就是填1个数字
    interrupts = &lt;36&gt;;            表明中断号是36，注意此处按照#interrupt-cells = &lt;1&gt;;的规定，只填1个数字。
    ti,hwmods = &quot;lcdc&quot;;
    status = &quot;disabled&quot;;
};
//定义gpio1控制器
gpio1: gpio@4804c000 {            gpio1这组gpio的控制器定义
    compatible = &quot;ti,omap4-gpio&quot;;
    ti,hwmods = &quot;gpio2&quot;;
    gpio-controller;            这句话表明这个是个gpio控制器
    #gpio-cells = &lt;2&gt;;            定义了gpio的填写格式是要填2个字节
    interrupt-controller;            表明这个是个中断控制器
    #interrupt-cells = &lt;2&gt;;        定义了中断的填写格式是要填2个字节
    reg = &lt;0x4804c000 0x1000&gt;;
    interrupts = &lt;98&gt;;            表明父中断号是98，但gpio控制器的中断本身，又可以追溯到具体哪个gpio产生的中断。
};注意这个gpio1内部的中断控制器，在属性上，比intc: interrupt-controller@48200000多了个interrupts属性，为什么？
    因为intc: interrupt-controller@48200000是一个总的中断控制器。而gpio1的中断控制器，内部其实是级联在intc: interrupt-controller@48200000上的。
    所以gpio1的中断控制器本身有个父中断，也就是interrupts = &lt;98&gt;;。
    这里有点奇怪，照理说，应该设置下interrupt-parent = &lt;&amp;intc&gt;;，指定下父中断源。
    只不过作为中断控制器，根据情况是可以不设置父中断号的，如果是最顶层一级的话。总之即使是中断控制器，也可能有 父中断号这个概念。
</code></pre><p>Documentation/devicetree/bindings/gpio/gpio-omap.txt：<br>    …</p>
<pre><code>- gpio-controller : Marks the device node as a GPIO controller.    这句话表明这个是个gpio控制器
- #gpio-cells : Should be two.                    规定#gpio-cells的个数是2个字节。第一个字节填gpio号。第二个字节预留。
  - first cell is the pin number
  - second cell is used to specify optional parameters (unused)
- interrupt-controller: Mark the device node as an interrupt controller.    这句话表明这个是个中断控制器
- #interrupt-cells : Should be 2.                定义了#interrupt-cells的个数是要填2个字节
  The first cell is the GPIO number.                下面几句定义了具体2个字节的含义。第一个字节是gpio号，第二个字节是中断类型。
  The second cell is used to specify flags:
    bits[3:0] trigger type and level flags:
      1 = low-to-high edge triggered.
      2 = high-to-low edge triggered.
      4 = active high level-sensitive.
      8 = active low level-sensitive.
...
</code></pre><p>Documentation/devicetree/bindings/interrupt-controller/ti,omap-intc-irq.txt：<br>    …<br>    Required Properties:</p>
<pre><code>- compatible: should be one of
        &quot;ti,omap2-intc&quot;
        &quot;ti,omap3-intc&quot;
        &quot;ti,dm814-intc&quot;
        &quot;ti,dm816-intc&quot;
        &quot;ti,am33xx-intc&quot;            是和这个compatible字段一样的

- interrupt-controller : Identifies the node as an interrupt controller
- #interrupt-cells : Specifies the number of cells needed to encode interrupt
         source, should be 1 for intc        #interrupt-cells此处被规定为一个字节，就是中断号
...
</code></pre><p>“interrupts-extended”的概念：<br>    如果父中断，不止一个，怎么办？<br>    The “interrupts-extended” property is a special form for use when a node needs to reference multiple interrupt parents.<br>    Each entry in this property contains both the parent phandle and the interrupt specifier. “interrupts-extended” should only be used when a device has multiple interrupt parents.<br>    这时候就要用到”interrupts-extended”。这个东西基本上和”interrupts”是一类概念，只是”interrupts-extended”表示的相当于复数，里面可以放不止一个父中断。<br>    设备会连接不同的中断控制器，然后可以触发不同的中断，由各自不同的中断控制器来接收处理。<br>举例：<br>tps659038: tps659038@58 {<br>    compatible = “ti,tps659038”;<br>    reg = <0x58>;<br>    interrupts-extended = &lt;&amp;gpio1 0 IRQ_TYPE_LEVEL_HIGH<br>               &amp;dra7_pmx_core 0x418&gt;;</0x58></p>
<pre><code>#interrupt-cells = &lt;2&gt;;
interrupt-controller;
[...]
</code></pre><p>}</p>
<p>2.实际使用的方法：<br>am335x-evm.dts:<br>        //i2c触屏控制芯片的例子<br>        &amp;i2c2 {<br>            pinctrl-names = “default”;<br>            pinctrl-0 = &lt;&amp;i2c2_pins&gt;;<br>            status = “okay”;<br>            clock-frequency = <400000>;<br>            gt911a: gt911a@5d {<br>                compatible = “goodix,gt911a”;<br>                pinctrl-names = “default”;<br>                pinctrl-0 = &lt;&amp;touchscreen_pins&gt;;<br>                reg = <0x5d>;<br>                interrupt-parent = &lt;&amp;gpio1&gt;;    这个代表是gpio1这组的，因为我们是gpio1_18作为中断。<br>                interrupts = <18 2="">;        这个是中断脚gpio1_18，后面的2代表下降沿触发，具体定义参考Documentation/devicetree/bindings/gpio/gpio-omap.txt #interrupt-cells<br>                reset-gpios = &lt;&amp;gpio1 26 0&gt;;    这个是reset脚gpio1_26，最后的0不代表任何意义，具体定义参考Documentation/devicetree/bindings/gpio/gpio-omap.txt #gpio-cells<br>                int-gpios = &lt;&amp;gpio1 18 0&gt;;        同上<br>            };<br>        };</18></0x5d></400000></p>
<pre><code>//mmc卡控制器的例子
&amp;mmc1 {                
    status = &quot;okay&quot;;
    vmmc-supply = &lt;&amp;vmmc_reg&gt;;
    bus-width = &lt;4&gt;;
    pinctrl-names = &quot;default&quot;;
    pinctrl-0 = &lt;&amp;mmc1_pins&gt;;
    cd-gpios = &lt;&amp;gpio0 6 GPIO_ACTIVE_LOW&gt;;    
    wp-gpios = &lt;&amp;gpio0 7 GPIO_ACTIVE_HIGH&gt;;
};
</code></pre><p>代码中对dts信息的获取：<br>    如何在platform设备中获取dts里面配置的中断信息？<br>        txirq = platform_get_irq_byname(pdev, “edma-tx”);<br>        此时对应dts里面的定义：<br>        interrupts = <0 8="" irq_type_level_high="">;<br>        interrupt-names = “edma-tx”;<br>        这样platform设备就得到具体的中断号了。</0></p>
<pre><code>如何在i2c设备中获取dts中配置的中断信息？
    在代码中，一旦dts中配置的i2c的中断。那么代码中probe函数的入参，也就是i2c_client的irq成员，就自动被赋值成dts里面配置的中断号了，且无需gpio_to_irq再转了。
    例如 static int goodix_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
    static struct i2c_driver goodix_ts_driver = {
        .probe      = goodix_ts_probe,
    对于goodix_ts_probe来说，client-&gt;irq就直接可以拿来request_irq()了

如何在代码中获取gpio信息？
    在触屏控制芯片的例子代码中，ts-&gt;reset_pin = of_get_named_gpio(dev-&gt;of_node,&quot;reset-gpios&quot;,0);可以获取reset-gpio的号。这个参数node是struct device的成员。
    在mmc卡控制器的例子中，比较特殊：
        在drivers\mmc\host\omap_hsmmc.c的omap_hsmmc_probe()，调用了ret = mmc_of_parse(mmc);
        而在drivers\mmc\core\host.c的mmc_of_parse()，里面有句mmc_gpiod_request_ro(host, &quot;wp&quot;, 0, false, 0, &amp;ro_gpio_invert);这个函数
        最终通过dts取出了wp-gpios的字段。同理还有cd-gpios
        由于并未直接使用of_get_named_gpio()，所以在内核代码里面直接搜wp-gpios是搜不到的。
        至于mmc_gpiod_request_ro()最终如何真正从dts中取出wp-gpios的值，这个函数很深，一路调用下去，最终会调用of_find_gpio()，这就是取出wp-gpios的地方了。
        有关mmc卡的dts的配置，可参考文档：
        Documentation/devicetree/bindings/mmc/mmc.txt
</code></pre><p>几个概念总结：（下面这些全部在Documentation/devicetree/bindings下面定义）<br>interrupt-controller    表明这个是个中断控制器</p>
<p>#interrupt-cells    这个表示中断的具体格式的数目，比如interrupts = <0 8="" irq_type_level_high="">;，包含3个元素，0 8 IRQ_TYPE_LEVEL_HIGH。这个是驱动自定义的。所以就等于3<br>interrupts        表示中断号，具体格式需要服从父节点的#interrupt-cells定义<br>interrupt-parent    表明父类继承的是哪个中断控制器<br>gpio-controller    这句话表明这个是个gpio控制器</0></p>
<p>#gpio-cells    表示gpio的具体格式的数目</p>
<p>gpio hogging的概念<br>                        hogging的意思是：<br>                            对于一些即使是将来也不可能属于任何驱动的gpio，内核可以在开机的时候<br>                            申请并设置下gpio的默认状态，比如这边的PIO line 111 (AMP_CONTROL) hogged as output/high<br>                        hog以后，就不可以在sysfs里面export对应的脚了，因为被request过了。<br>                        并且，只有用hog的情况下，才能真正把gpio的状态确定下来，比如开机输出为高。否则不带gpio-hog，则输出值的设定其实是无效果的。<br>                        以AMP_CONTROL    gpio0_15为例<br>                        &amp;gpio0 {<br>                            pinctrl-names = “default”;<br>                            pinctrl-0 = &lt;&amp;etcs_gpio_default&gt;;</p>
<pre><code>    p15 {
        gpio-hog;
        gpios = &lt;15 GPIO_ACTIVE_LOW&gt;;        指低为有效值
        output-high;                指输出有效值
        line-name = &quot;AMP_CONTROL&quot;;
    };
};
开机有这句话打出
GPIO line 111 (AMP_CONTROL) hogged as output/high

配置内核来使能debugfs
 Symbol: DEBUG_FS [=y]
  Type  : boolean
  Prompt: Debug Filesystem
    Defined at lib/Kconfig.debug:77
    Location:
    -&gt; Kernel hacking
       启动目标硬件并挂载debugfs
mount -t debugfs none /sys/kernel/debug
cat /sys/kernel/debug/gpio可以看到hogging过后已经被申请占用的脚
GPIOs 0-31, platform/4804c000.gpio, gpio:
 gpio-16  (                    |wlan-en-regulator   ) out lo

GPIOs 32-63, platform/481ac000.gpio, gpio:

GPIOs 64-95, platform/481ae000.gpio, gpio:

GPIOs 96-127, platform/44e07000.gpio, gpio:
 gpio-102 (                    |cd                  ) in  hi IRQ
 gpio-103 (                    |wp                  ) in  lo
 gpio-111 (                    |AMP_CONTROL         ) out lo        &lt;-------可看到这个是hogging已经request掉的gpio
 gpio-115 (                    |GTP_RST_PORT        ) in  lo
 gpio-116 (                    |GTP_INT_IRQ         ) in  lo IRQ
 gpio-125 (                    |?                   ) out lo

GPIOs 504-509, platform/tps65910-gpio, tps65910, can sleep:

GPIOs 510-511, platform/50000000.gpmc, omap-gpmc:
 gpio-510 (                    |rb                  ) in  hi
此时如果：
echo 111 &gt; /sys/class/gpio/export
-sh: echo: write error: Device or resource busy
也就是说这个引脚资源已经被申请掉了。且不可释放。
</code></pre><p>========================Interrupt和gpio属性=============================</p>
<p>========================clock属性=============================<br>clock实例：</p>
<p>soc     {<br>    coreclk: mvebu-sar@18230 {<br>        compatible = “marvell,armada-xp-core-clock”;<br>        reg = <0x18230 0x08="">;</0x18230></p>
<pre><code>    #clock-cells = &lt;1&gt;;
};

cpuclk: clock-complex@18700 {
    #clock-cells = &lt;1&gt;;
    compatible = &quot;marvell,armada-xp-cpu-clock&quot;;
    reg = &lt;0x18700 0xA0&gt;;
    clocks = &lt;&amp;coreclk 1&gt;;
};

gateclk: clock-gating-control@18220 {
    compatible = &quot;marvell,armada-xp-gating-clock&quot;;
    reg = &lt;0x18220 0x4&gt;;
    clocks = &lt;&amp;coreclk 0&gt;;
    #clock-cells = &lt;1&gt;;
};
</code></pre><p>}</p>
<p>clocks {<br>    /<em> 25 MHz reference crystal </em>/<br>    refclk: oscillator {<br>        compatible = “fixed-clock”;</p>
<pre><code>    #clock-cells = &lt;0&gt;;
    clock-frequency = &lt;25000000&gt;;
};
</code></pre><p>};</p>
<p>clock的使用者：</p>
<p>CPU, using a cpuclk</p>
<p>cpu@0 {<br>    device_type = “cpu”;<br>    compatible = “marvell,sheeva-v7”;<br>    reg = <0>;<br>    clocks = &lt;&amp;cpuclk 0&gt;;<br>};</0></p>
<p>Timer, using either a coreclk or refclk</p>
<p>timer@20300 {<br>    compatible = “marvell,armada-xp-timer”;<br>    clocks = &lt;&amp;coreclk 2&gt;, &lt;&amp;refclk&gt;;<br>    clock-names = “nbclk”, “fixed”;<br>};</p>
<p>USB, using a gateclk<br>usb@52000 {<br>    compatible = “marvell,orion-ehci”;<br>    reg = <0x52000 0x500="">;<br>    interrupts = <47>;<br>    clocks = &lt;&amp;gateclk 20&gt;;<br>    status = “disabled”;<br>}<br>========================clock属性=============================</47></0x52000></p>
<p>========================pinctrl属性=============================<br>举例：<br>ssp0: ssp@80010000 {<br>    pinctrl-names = “default”;<br>    pinctrl-0 = &lt;&amp;mmc0_8bit_pins_a<br>        &amp;mmc0_cd_cfg &amp;mmc0_sck_cfg&gt;;<br>    […]<br>};<br>具体见<br>Linux\Kernel\驱动\Pinctrl\笔记.txt<br>========================pinctrl属性=============================</p>
<p>========================of函数=============================<br>linux下devicetree中常用的of函数<br>这个函数的第一个参数就是device_node结构体。<br>这个device_node，是作为device结构体中的一个成员出现的。<br>struct device {<br>    …<br>    struct device_node    <em>of_node; /</em> associated device tree node <em>/<br>    …<br>}<br>所以有了device，就找到了device_node。<br>从device_node中获取信息：<br>int of_property_read_u8_array(const struct device_node </em>np, const char <em>propname,u8 </em>out_values, size_t sz);<br>int of_property_read_u16_array(const struct device_node <em>np, const char </em>propname,u16 <em>out_values, size_t sz);<br>int of_property_read_u32_array(const struct device_node </em>np, const char <em>propname,u32 </em>out_values, size_t sz);<br>从设备结点np中读取属性名为propname，类型为8、16、32、位整型数组的属性值，并放入out_values，sz指明了要读取的个数。</p>
<p>static inline int of_property_read_u8(const struct device_node <em>np,const char </em>propname,u8 <em>out_value)<br>static inline int of_property_read_u16(const struct device_node </em>np,const char <em>propname,u8 </em>out_value)<br>static inline int of_property_read_u32(const struct device_node <em>np,const char </em>propname,u8 *out_value)<br>从设备结点np中读取属性名为propname，类型为8、16、32位的属性值，并放入out_values。实际上这里调用的就是sz为1的of_property_read_uxx_array函数。</p>
<p>int of_property_read_u32_index(const struct device_node <em>np,const char</em>propname,u32 index, u32 *out_value)<br>从设备结点np中读取属性名为propname的属性值中第index个u32数值给out_value</p>
<p>int of_property_read_u64(conststruct device_node <em>np, const char </em>propname,u64 *out_value)<br>从设备结点np中读取属性名为propname，类型为64位的属性值，并放入out_values</p>
<p>int of_property_read_string(struct device_node <em>np, const char </em>propname,const char**out_string)<br>从设备结点np中读取属性名为propname的字符串型属性值</p>
<p>int of_property_read_string_index(struct device_node <em>np, const char </em>propname,intindex, const char **output)<br>从设备结点np中读取属性名为propname的字符串型属性值数组中的第index个字符串</p>
<p>int of_property_count_strings(struct device_node <em>np, const char </em>propname)<br>从设备结点np中读取属性名为propname的字符串型属性值的个数</p>
<p>unsigned int irq_of_parse_and_map(struct device_node *dev, int index)<br>从设备节点dev中读取第index个irq号</p>
<p>int of_irq_to_resource(struct device_node <em>dev, int index, struct resource </em>r)<br>从设备节点dev中读取第index个irq号，并填充一个irq资源结构体</p>
<p>int of_irq_count(struct device_node *dev)<br>获取设备节点dev的irq个数</p>
<p>static inline bool of_property_read_bool(const struct device_node <em>np,const char </em>propname);<br>如果设备结点np含有propname属性，则返回true，否则返回false。一般用于检查空属性是否存在。</p>
<p>struct property<em> of_find_property(const struct device_node </em>np,const char <em>name,int </em>lenp)<br>根据name参数，在指定的设备结点np中查找匹配的property，并返回这个property</p>
<p>const void <em> of_get_property(const struct device_node </em>np, const char <em>name,int </em>lenp)<br>根据name参数，在指定的设备结点np中查找匹配的property，并返回这个property的属性值</p>
<p>struct device_node<em> of_get_parent(const struct device_node </em>node)<br>获得node节点的父节点的device node</p>
<p>int of_device_is_compatible(const struct device_node <em>device,const char </em>compat);<br>判断设备结点device的compatible属性是否包含compat指定的字符串</p>
<p>从of_allnodes中查找信息：<br>struct device_node<em> of_find_node_by_path(const char </em>path)<br>根据路径参数，在全局链表of_allnodes中，查找匹配的device_node</p>
<p>struct device_node<em> of_find_node_by_name(struct device_node </em>from,const char *name)<br>则根据name在全局链表of_allnodes中查找匹配的device_node,若from=NULL表示从头开始查找</p>
<p>struct device_node<em> of_find_node_by_type(struct device_node </em>from,const char *type)<br>根据设备类型在全局链表of_allnodes中查找匹配的device_node</p>
<p>struct device_node <em> of_find_compatible_node(struct device_node </em>from, const char<em>type, const char，</em>compatible);<br>根据compatible的属性值在全局链表of_allnodes中查找匹配的device_node，大多数情况下，from、type为NULL。</p>
<p>struct device_node<em> of_find_node_with_property(struct device_node </em>from,const char *prop_name)<br>根据节点属性的name在全局链表of_allnodes中查找匹配的device_node</p>
<p>struct device_node* of_find_node_by_phandle(phandle handle)<br>根据phandle在全局链表of_allnodes中查找匹配的device_node</p>
<p>杂：<br>void __iomem<em> of_iomap(struct device_node </em>node, int index);<br>通过设备结点直接进行设备内存区间的 ioremap()，index是内存段的索引。若设备结点的reg属性有多段，可通过index标示要ioremap的是哪一段，只有1段的情况，index为0</p>
<p>unsigned long __init of_get_flat_dt_root(void)<br>用来查找在dtb中的根节点，好像返回的都是0</p>
<p>int of_alias_get_id(struct device_node <em>np, const char </em>stem)<br>获取节点np对应的aliasid号</p>
<p>struct device_node<em> of_node_get(struct device_node </em>node)<br>void of_node_put(struct device_node *node)<br>device node计数增加/减少</p>
<p>const struct of_device_id<em> of_match_node(const struct of_device_id </em>matches,const struct device_node*node)<br>将matches数组中of_device_id结构的name和type与device node的compatible和type匹配，返回匹配度最高的of_device_id结构</p>
<p>platform_device和resource相关：<br>int of_address_to_resource(struct device_node <em>dev, int index,struct resource </em>r)<br>根据设备节点dev的reg属性值，填充资源结构体resource。Index参数指明了使用reg属性中第几个属性值，一般设置为0，表示第一个。<br>Translate device tree address and return as resource<br>以往用platform驱动的时候，都是直接定义resource的。现在变成of_address_to_resource，把dts里面的reg字段，翻译成resource。<br>然后就可以用platform_get_resource和devm_ioremap_resource来使用dts里面写的寄存器基地址信息。</p>
<p>struct platform_device<em> of_device_alloc(struct device_node </em>np,const char <em>bus_id,struct device </em>parent)<br>根据device node，bus_id以及父节点创建该设备的platform_device结构，同时会初始化它的resource成员。</p>
<p>int of_platform_bus_probe(struct device_node <em>root,const struct of_device_id </em>matches,struct device *parent)<br>遍历of_allnodes中的节点挂接到of_platform_bus_type总线上,由于此时of_platform_bus_type总线上还没有驱动,所以此时不进行匹配</p>
<p>int of_platform_populate(struct device_node <em>root,const struct of_device_id </em>matches,const struct of_dev_auxdata <em>lookup,struct device </em>parent)<br>遍历of_allnodes中的所有节点，生成并初始化所以节点的platform_device结构</p>
<p>struct platform_device<em> of_find_device_by_node(struct device_node </em>np)<br>根据device_node查找返回该设备对应的platform_device结构<br>========================of函数=============================<br>========================compatible节点实际使用的例子1=============================<br>dts配置：<br>&amp;i2c2 {<br>    pinctrl-names = “default”;<br>    pinctrl-0 = &lt;&amp;i2c2_pins&gt;;</p>
<pre><code>status = &quot;okay&quot;;
clock-frequency = &lt;400000&gt;;

gt911a: gt911a@5d {
    compatible = &quot;goodix,gt911a&quot;;
    reg = &lt;0x5d&gt;;
};
</code></pre><p>};<br>注意到这个gt911a的compatible字段是”goodix,gt911a”</p>
<p>代码里面的设置：（gt9xx.c）<br>static const struct of_device_id gt911a_of_match[] = {<br>    { .compatible = “goodix,gt911a”, },<br>    { }<br>};<br>MODULE_DEVICE_TABLE(of, gt911a_of_match);</p>
<p>static struct i2c_driver goodix_ts_driver = {<br>    .probe      = goodix_ts_probe,<br>    .remove     = goodix_ts_remove,</p>
<p>#ifndef CONFIG_HAS_EARLYSUSPEND<br>    //.suspend    = goodix_ts_early_suspend,<br>    //.resume     = goodix_ts_late_resume,</p>
<p>#endif<br>    .id_table   = goodix_ts_id,<br>    .driver = {<br>        .name     = GTP_I2C_NAME,<br>        .owner    = THIS_MODULE,<br>    .of_match_table = gt911a_of_match,<br>    },<br>};<br>可以看到，定义了一个of_device_id gt911a_of_match[]的结构体，这里面就有.compatible = “goodix,gt911a”，和dts一致。<br>并且这个of_device_id结构体，是要注册到i2c_driver.driver.of_match_table的。<br>这样开机的时候，kernel发现代码的compatible字段和dts的compatible字段匹配，就会调用i2c_driver.probe函数了</p>
<p>另外。针对i2c_driver，其实不是用of_match_table一样可以通过dts匹配到i2c_driver然后probe。细节如下：<br>    其实是因为，以i2c_driver为例。<br>    可以有两种方法，通过dts匹配到i2c_driver从而进行probe。<br>    1.i2c_driver.driver.of_match_table.compatible定义一个字段，然后在dts里面的compatible = “xxx”;使用这个字段<br>    2.i2c_driver.id_table.name定义一个字段，然后在dts里面的compatible = “xxx”;使用这个字段<br>    给人的感觉，其实第一种方法，是比较通用的方法，因为这个of_match_table.compatible，是在device_driver{}结构体里面的。<br>    而第二种方法，是针对i2c_driver比较简便的方法，这样就不用特别去定义of_match_table.compatible了。<br>见下面这个例子：<br>&amp;i2c0 {<br>    …<br>    24c512@52 {<br>        compatible = “24c512”;        其实这个24c512字段，仅存在于i2c_driver.id_table.name中，drivers\misc\eeprom\at24.c中并无of_match_table<br>        reg = <0x52>;<br>    };<br>};</0x52></p>
<p>========================compatible节点实际使用的例子1=============================</p>
<p>========================compatible节点实际使用的例子2=============================<br>上面的例子1，实际是引用了#include “am33xx.dtsi”这里面的i2c2<br>所以书写的时候，需要写&amp;i2c2<br>这属于#include “am33xx.dtsi”来包含SOC的一些已有的功能。<br>那如果是单独使用内核驱动中的一些compatible字段呢？<br>以内核的Device Drivers  —&gt;[<em>] LED Support  —&gt;&lt;</em>&gt;   LED Support for GPIO connected LEDs驱动为例。<br>需要这么做：<br>1.加入相应的头文件，这样就可以使用一些现成的宏定义了</p>
<p>#include &lt;dt-bindings/gpio/gpio.h&gt;<br>打开include/dt-bindings/gpio/gpio.h，可以看到一些可供使用的宏定义：<br>/<em> Bit 0 express polarity </em>/</p>
<p>#define GPIO_ACTIVE_HIGH 0</p>
<p>#define GPIO_ACTIVE_LOW 1<br>2.在dts头部的大括号里面加，不要在dts后部应用SOC的节点（如&amp;i2c2）那里加。如下：<br>/ {<br>    model = “TI AM335x EVM”;<br>    compatible = “ti,am335x-evm”, “ti,am33xx”;</p>
<pre><code>cpus {
    cpu@0 {
        cpu0-supply = &lt;&amp;vdd1_reg&gt;;
    };
};

memory {
    device_type = &quot;memory&quot;;
    reg = &lt;0x80000000 0x20000000&gt;; /* 512 MB */
};

leds {                            &lt;----------------------在这里加
    pinctrl-names = &quot;default&quot;;
    pinctrl-0 = &lt;&amp;user_leds_default&gt;;
    compatible = &quot;gpio-leds&quot;;
    beep {
        label = &quot;etcs-beep&quot;;
        gpios = &lt;&amp;gpio0 29 GPIO_ACTIVE_HIGH&gt;;
        default-state = &quot;off&quot;;
    };
};
</code></pre><p>};</p>
<p>&amp;uart0 {<br>    pinctrl-names = “default”;<br>    pinctrl-0 = &lt;&amp;uart0_pins&gt;;</p>
<pre><code>status = &quot;okay&quot;;
</code></pre><p>};<br>                                &lt;———————-不能在这里加<br>========================compatible节点实际使用的例子2=============================</p>
<p>========================spi_device节点实际使用的例子=============================<br>&amp;spi0 {<br>    status = “okay”;<br>    pinctrl-names = “default”;<br>    pinctrl-0 = &lt;&amp;spi0_pins_default&gt;;</p>
<pre><code>gpio_spi: gpio_spi@0 {
    compatible = &quot;fairchild,74hc595&quot;;
    gpio-controller;                //Marks the device node as a gpio controller.
    #gpio-cells = &lt;2&gt;;                //Should be two.  The first cell is the pin number and the second cell is used to specify the gpio polarity:
    reg = &lt;0&gt;;                //chip select number
    registers-number = &lt;2&gt;;            //Number of daisy-chained shift registers
    spi-max-frequency = &lt;100000&gt;;        //SPI频率
    spi-cpha;                    //意味着spi-cpha=1
    spi-cpol;                    //意味着spi-cpol=1
};
</code></pre><p>};</p>
<ul>
<li>spi-cpol        - (optional) Empty property indicating device requires inverse clock polarity (CPOL) mode</li>
<li>spi-cpha        - (optional) Empty property indicating device requires shifted clock phase (CPHA) mode</li>
</ul>
<p>参考文档：<br>Documentation\devicetree\bindings\spi\spi-bus.txt<br>========================spi_device节点实际使用的例子=============================</p>
<p>========================gpio-controller节点的定义及其引用的例子=============================<br>定义一个gpio-controller。对应驱动里面，就是gpiochip_add()<br>&amp;spi0 {<br>    status = “okay”;<br>    pinctrl-names = “default”;<br>    pinctrl-0 = &lt;&amp;spi0_pins_default&gt;;</p>
<pre><code>gpio_spi: gpio_spi@0 {
    compatible = &quot;fairchild,74hc595&quot;;
    gpio-controller;                //Marks the device node as a gpio controller.
    #gpio-cells = &lt;2&gt;;                //Should be two.  The first cell is the pin number and the second cell is used to specify the gpio polarity:
    reg = &lt;0&gt;;                //chip select number
    registers-number = &lt;2&gt;;            //Number of daisy-chained shift registers
    spi-max-frequency = &lt;100000&gt;;        //SPI频率
    spi-cpha;                    //意味着spi-cpha=1
    spi-cpol;                    //意味着spi-cpol=1
};
</code></pre><p>};<br>上面这个例子中，这个gpio-controller的名字是gpio_spi</p>
<p>实际去引用这个gpio-controller：<br>    hogging的例子：<br>                &amp;gpio_spi {<br>                    gpio496 {<br>                        gpio-hog;<br>                        gpios = <0 gpio_active_low="">;<br>                        output-low;<br>                        line-name = “D11_green”;<br>                    };<br>                    gpio497 {<br>                        gpio-hog;<br>                        gpios = <1 gpio_active_low="">;<br>                        output-low;<br>                        line-name = “D11_yellow”;<br>                    };<br>                };<br>    gpio-led的例子：<br>    leds {<br>        pinctrl-names = “default”;<br>        pinctrl-0 = &lt;&amp;user_leds_default&gt;;<br>        compatible = “gpio-leds”;</1></0></p>
<pre><code>    D11_green {
        label = &quot;D11_green&quot;;
        gpios = &lt;&amp;gpio_spi 0 GPIO_ACTIVE_LOW&gt;;
        default-state = &quot;off&quot;;
    };
}
</code></pre><p>========================gpio-controller节点的定义及其引用的例子=============================</p>
<p>========================kernel启动以后查看device tree的配置=============================<br>a. /sys/firmware/fdt               </p>
<p>进入/sys/firmware目录后便可看到二个文件，一个是devicetree文件夹，另一个是fdt（原始dtb文件，可以用hexdump -C fdt 将其打印出来查看就会发现里面的数据和dtb文件是一致的）。</p>
<p>b. /sys/firmware/devicetree</p>
<p>以目录结构呈现的dtb文件。 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件</p>
<p>c. /sys/devices/platform</p>
<p>系统中所有的platform_device, 有来自设备树的, 也有来有.c文件中注册的<br>对于来自设备树的platform_device,可以进入 /sys/devices/platform/&lt;设备名&gt;/of_node 查看它的设备树属性（例如进入/sys/devices/platform/led/后若发现该目录下有of_node节点，就表明该platform_device来自设备树）</p>
<p>d. /proc/device-tree</p>
<p>是链接文件, 指向 /sys/firmware/devicetree/base<br>========================kernel启动以后查看device tree的配置=============================</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/29/Character-Device/" rel="next" title="Character Device">
                <i class="fa fa-chevron-left"></i> Character Device
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/29/DMA/" rel="prev" title="DMA">
                DMA <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Semiyd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">241</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">130</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semiyd</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
