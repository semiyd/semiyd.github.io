<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Audio类的使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Audio类的使用">
<meta property="og:url" content="http://yoursite.com/2020/07/12/Audio类的使用/index.html">
<meta property="og:site_name" content="Semiyd&#39;s Blog">
<meta property="og:description" content="Audio类的使用">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-07-12T13:09:17.369Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Audio类的使用">
<meta name="twitter:description" content="Audio类的使用">






  <link rel="canonical" href="http://yoursite.com/2020/07/12/Audio类的使用/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Audio类的使用 | Semiyd's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Semiyd's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/12/Audio类的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Semiyd">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Semiyd's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Audio类的使用
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2020-07-12 14:54:04 / Modified: 21:09:17" itemprop="dateCreated datePublished" datetime="2020-07-12T14:54:04+08:00">2020-07-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/AOSP/" itemprop="url" rel="index"><span itemprop="name">AOSP</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/AOSP/Develop/" itemprop="url" rel="index"><span itemprop="name">Develop</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/AOSP/Develop/Audio/" itemprop="url" rel="index"><span itemprop="name">Audio</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/AOSP/Develop/Audio/Overview/" itemprop="url" rel="index"><span itemprop="name">Overview</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><center><strong>Audio类的使用</strong></center><br><a id="more"></a></p>
<p>—————–类的使用———————<br>录音部分：<br>AudioRecord.cpp / AudioRecord.java(只是前者的JAVA封装)</p>
<ol>
<li>创建一个数据流。</li>
<li>构造一个AudioRecord对象，其中需要的最小录音缓存buffer大小可以通过getMinBufferSize方法得到。如果buffer容量过小，将导致对象构造的失败。</li>
<li>初始化一个buffer，该buffer大于等于AudioRecord对象用于写声音数据的buffer大小。</li>
<li>开始录音。</li>
<li>从AudioRecord中读取声音数据到初始化buffer，将buffer中数据导入数据流。</li>
<li>停止录音。</li>
<li>关闭数据流。<br>对应的AudioRecord.cpp的使用代码：<br>AudioRecord  pAudioRecord  = new android::AudioRecord();<br>pAudioRecord-&gt;set( inputSource,<pre><code>sampleRateInHz,
audioFormat,
channelConfig,
minFrameCount,
AudioRecordCallback,
NULL,
0,
true,
0,
</code></pre>android::AudioRecord::TRANSFER_DEFAULT,<br>AUDIO_INPUT_FLAG_NONE, //AUDIO_INPUT_FLAG_NONE //audio_input_flags_t flags);<br>NULL<br>);<br>或<br>AudioRecord recordInstance = new AudioRecord(<pre><code>MediaRecorder.AudioSource.REMOTE_SUBMIX, frequency,
AudioFormat.CHANNEL_IN_MONO, audioEncoding, bufferSize);
</code></pre>recordInstance.startRecording();<br>//AudioRecod.cpp中的set()函数，看来一些限制：<br>AudioRecod.set(){<br>if (inputSource == AUDIO_SOURCE_DEFAULT) {** //默认录制音源，即是MIC<br> inputSource = AUDIO_SOURCE_MIC;<br>}<br>if (sampleRate == 0) {<br>ALOGE(“Invalid sample rate %u”, sampleRate);<br>return BAD_VALUE;<br>}</li>
</ol>
<p>// these below should probably come from the audioFlinger too…<br>if (format == AUDIO_FORMAT_DEFAULT) {<strong>//默认数据格式，即是</strong>AUDIO_FORMAT_PCM_16_BIT<br>    format = AUDIO_FORMAT_PCM_16_BIT;<br>}</p>
<p>// Temporary restriction: AudioFlinger currently supports 16-bit PCM only<br>if (format != AUDIO_FORMAT_PCM_16_BIT) {<strong>//数据格式，其实只能是</strong>AUDIO_FORMAT_PCM_16_BIT<br>    ALOGE(“Format %#x is not supported”, format);<br>    return BAD_VALUE;<br>}</p>
<p>}<br>总结下，就是MIC，通话进出，REMOTE_SUBMIX，CAMCORDER(录像用的mic，一般没有独立，最终其实也是默认的MIC)。<br>所以有些东西还是录制不到的，比如主设备混音后输出的声音，这包括了各种可能的音乐、铃声、通知等声音。<br>也就是，Android给到上层应用的接口是，只能给你录制MIC，录制通话，录像。其余录音场景，不给。</p>
<p>相关类说明</p>
<p>多媒体管理类<br>MediaScannerService<br>三种广播的扫描流程<br>三种广播的扫描路径<br>MediaProvider<br>MediaReceiver<br>MediaStore<br>播放与录制，JAVA层<br>MediaPlayer<br>封装给App层，用于播放音视频多媒体的类<br>状态迁移图<br>框架图<br>MediaRecorder<br>封装给App层，用于录制音视频多媒体的类。非常友好的封装，录制、编码、存储等所有细节都被封装起来。<em>**</em><br>状态迁移图<br>框架图</p>
<p>AudioRecord.java<br>封装给APP层的音频录制类，提供非常友好，简化的接口和调用流程。<br>通过JNI封装了AudioRecord.cpp功能类的具体事务操作。<br>JNI文件：android_media_AudioRecord.cpp<br>AudioTrack.java<br>AudioTrack.cpp的java层封装类，播放音频<br>AudioTrack.cpp<br>用于音频数据的回放。<br>分两类数据传送模式：<br>主动push 和 被pull<br>分两类数据操作模式：<br>static<br>数据量小，时间短，如铃音、通知、音效。数据一次性交付，然后播放。<br>stream<br>数据量大，时间长，如音乐等。数据通过共享内存方式传送，以流形式传输播放。<strong><strong><br>AudioRecord.cpp<br>音频录制功能类，client端，服务端才是真正执行录制工作的。<br>AudioRecord:</strong></strong>AudioRecordThread</p>
<p>框架层<br>MediaPlayerService<br>APP层MediaPlayer和MediaRecorder的服务端，播放和录制操作的服务类，向下调用真正播放和操作的执行类与功能类。<br>MediaRecoderClient<br>与客户端MediaRecorde<strong><strong>r对应的服务端的助理类，多实例，一一对应关系。<br>StageFrightRecoder<br>直接的录制器，录制操作的执行类。<br>Client<br>与客户端MediaPlaye</strong></strong>r对应的服务端的助理类，多实例，一一对应关系。<em>**</em><br>各种播放器类<br>类型有：NU_PLAYER, PV_PLAYER等</p>
<p>AudioSystem.cpp<br>包装类，隔离AudioTrack/AudioRecord类 &lt;==&gt; AudioPolicyService、AudioFlinger。<br>因此向上提供统一接口，隔离后者策略类、音频服务类的变化。<br>看其实现，就是中转调用，转给AudioPolicyService或AudioFlinger。<br>AudioService<br>AudioFlinger<br>AudioFlinger(下面简称AF)是整个音频系统的核心与难点。作为Android系统中的音频中枢，它同时也是一个系统服务，启到承上(为上层提供访问接口)启下(通过HAL来管理音频设备)的作用。AudioFlinger向下访问AudioHardware，实现输出音频数据，控制音频参数。<br>AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。<br>AudioFlinger–&gt;PlaybackThread<br>负责回放音频数据工作的线程类<br><strong>AudioFlinger–&gt;MixerThread<br>负责混音工作的线程类
</strong>AudioFlinger–&gt;MixerThread–&gt;AudioMixer<br>负责混音具体事务的功能类<br>@ AudioFlinger的创建与初始化<br>创建见书，<br>TODO： 初始化<br>@ 对音频设备的管理<br>AudioPolicyManagerBase 构造函数中，AudioPolicyManagerBase-&gt;loadAudioPolicyConfig，对 audio_policy.conf加载、解析， 找出可用的音频设备 -&gt; AudioFlinger加载模块<br>AudioPolicyService<br>AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。AudioPolicyService根据用户配置来指导AudioFlinger加载设备接口，起到路由功能。<br>audio_policy.conf<br>不同的Android产品在音频(设备)的设计上通常是存在差异的，而这些差异可以同过Audio的配置文件audio_policy.conf来获得。在Android系统中音频配置文件存放路径有两处，存放地址可以从AudioPolicyManagerBase.cpp文件中知道：</p>
<p> #define AUDIO_POLICY_VENDOR_CONFIG_FILE  “/vendor/etc/audio_policy.conf”</p>
<p> #define AUDIO_POLICY_CONFIG_FILE         “/system/etc/audio_policy.conf”</p>
<p>在AudioPolicyManager.cpp文件中可以知道系统会首先加载vendor/etc目录下的configure文件，再加载system/etc目录下的configure文件。若这两者加载都发生错误的话，系统会加载default配置文件，并命名为primary module，从这可以看出，音频系统中一定必须存在的module就是primary了。<br>TODO: 这些个配置，什么来由，在代码中如何加载，处理，生成对应的audio_hw_device_t，上层如何来用这些信息，干嘛用。<br>在HAL层，一个音频设备，用一个 audio_hw_device_t 结构体来表示，而它支持的输出类型，在audio_policy.conf被指明。<br>当上层要打开一个OUT通道时，会寻找匹配的类型，进行打开。<br>audio_effects.conf<br>音效配置文件，最终机器，一般存放在：<br>/system/etc/audio_effects.conf<br>/vendor/etc/audio_effects.conf<br>struct default_audio_policy {<br>struct audio_policy policy;</p>
<p>struct audio_policy_service_ops <em>aps_ops;<br>void </em>service;<br>};</p>
<p>AudioPolicyManagerBase<br>是什么，干什么用？<br>初始化过程： AudioPolicyService构造中： rc = mpAudioPolicyDev-&gt;create_audio_policy(mpAudioPolicyDev, &amp;aps_ops, this,<br>&amp;mpAudioPolicy); -&gt; …. -&gt; AudioPolicyManagerBase<br>@ Audio策略类的路由功能？<br>何谓路由功能，路由过程是怎样的？<br>audio.h中的输出设备类型是怎么回事？ 与audio_policy.conf有什么关系？<br>policy类是如何使用这些定义及配置的？<br>最终如何选择到合适的输出设备，即对应audio_deivce类，找到对应输出通道，即audio_deivce -&gt;openOutputStream，具体打开哪一个？<br>Android上层定义的声音流类型，又是如何对应下来的？<br><strong>据说上面调用下来，辗转libaudiopolicy.so 后，到AudioPolicyManagerBase.getDevicesForStream()-&gt;**</strong>.getDeviceForStrategy()， 里面正是AudioSystem.java/AudioSystemLegacy.h中定义的声音流类型与audio.h中定义的音频设备类型转换过程。</p>
<p>—————–旧版HAL的实现———————</p>
<p>Audio HAL层架构定义： hardware\libhardware\include\hardware\audio.h<br>以audio.primary.grouper.so库为例， 具体厂家是asus的话，代码位置device\asus\grouper\audio\audio_hw.c<br>//Audio HAL层架构中audio_module 的定义，继承hw_module_t，其实没有任何扩展<br>struct audio_module {<br>  struct hw_module_t common;<br>};</p>
<p>// 厂商audio_module 的实现，关键是open函数赋值，其作用是打开该设备，返回audio_hw_device 结构体对象，但在这份实现中，返回是audio_device对象，即audio_hw_device子类<br>struct audio_module HAL_MODULE_INFO_SYM = {<br>    .common = {<br>      .tag = HARDWARE_MODULE_TAG,<br>      .module_api_version = AUDIO_MODULE_API_VERSION_0_1,<br>      .hal_api_version = HARDWARE_HAL_API_VERSION,<br>      .id = AUDIO_HARDWARE_MODULE_ID,<br>      .name = “Grouper audio HW HAL”,<br>      .author = “The Android Open Source Project”,<br>      .methods = &amp;hal_module_methods,<br>  },<br>};</p>
<p>static struct hw_module_methods_t hal_module_methods = {<br>    .open = adev_open, //open函数主要是填充audio_hw_device 结构体对象，返回之<br>};</p>
<p>//Audio HAL层架构中audio_hw_device的定义，audio_hw_device 继承自hw_device_t。<br>//可以看到跟上层调用者的接口很一致，其实，它的作用就是为上层提供统一、稳定的接口，从而让底层的频繁变化，可以不影响上层的架构。<br>struct audio_hw_device {<br>    struct hw_device_t common;</p>
<pre><code>uint32_t (*get_supported_devices)(const struct audio_hw_device *dev);
int (*init_check)(const struct audio_hw_device *dev);
int (*set_voice_volume)(struct audio_hw_device *dev, float volume);
int (*set_master_volume)(struct audio_hw_device *dev, float volume);
int (*get_master_volume)(struct audio_hw_device *dev, float *volume);
int (*set_mode)(struct audio_hw_device *dev, audio_mode_t mode);
int (*set_mic_mute)(struct audio_hw_device *dev, bool state);
int (*get_mic_mute)(const struct audio_hw_device *dev, bool *state);
int (*set_parameters)(struct audio_hw_device *dev, const char *kv_pairs);
char * (*get_parameters)(const struct audio_hw_device *dev,
                     const char *keys);
size_t (*get_input_buffer_size)(const struct audio_hw_device *dev,
                            const struct audio_config *config);
int (*open_output_stream)(struct audio_hw_device *dev,
                      audio_io_handle_t handle,
                      audio_devices_t devices,
                      audio_output_flags_t flags,
                      struct audio_config *config,
                      struct audio_stream_out **stream_out);
void (*close_output_stream)(struct audio_hw_device *dev,
                        struct audio_stream_out* stream_out);
int (*open_input_stream)(struct audio_hw_device *dev,
                     audio_io_handle_t handle,
                     audio_devices_t devices,
                     struct audio_config *config,
                     struct audio_stream_in **stream_in);
void (*close_input_stream)(struct audio_hw_device *dev,
                       struct audio_stream_in *stream_in);
int (*dump)(const struct audio_hw_device *dev, int fd);
</code></pre><p>};<br>typedef struct audio_hw_device audio_hw_device_t;</p>
<p>//厂商中audio_hw_device 的实现，audio_device 继承自audio_hw_device。关键在于stream_out / stream_in 两个类<br>//Audio HAL层架构中，audio_stream_out / audio_stream_in 代表输出/输入流<br>//这里是实现类，关键是struct pcm <em>pcm; 它已经就是alsa库里定义的结构体了。它的初始化也正是调用alsa库的open_pcm()函数而来。<br>// out-&gt;pcm = pcm_open(PCM_CARD, device, PCM_OUT | PCM_NORESTART, out-&gt;pcm_config);<br>//所以，意思就是，从这里开始，往下就是调用alsalib库了。<br>struct stream_out {<br>    struct audio_stream_out stream;<br>    struct pcm </em>pcm;<br>    …<br>};</p>
<p>struct stream_in {<br>    struct audio_stream_in stream;<br>    struct pcm *pcm;<br>   …<br>};</p>
<p>audio设备打开流程<br>audio_policy.conf加载、解析之后的流程，见前面<br>audio_policy.conf加载、解析之后的流程如下：<br>厂商的Audio HAL模块加载流程:<br>AudioFlinger::loadHwModule(const char *name)<br>-&gt; load_audio_interface()<br>-&gt; hw_get_module_by_class()<br>//参考HAL框架加载知识，这里加载到相应.so的xxx_hw_module_t 结构体<br>-&gt; audio_hw_device_open() –&gt; xxx_hw_module_t.open() ，在参数里返回audio_hw_device_t结构体<br>至此，已经加载了HAL模块.so库，并打开相应设备，返回我们要的audio_hw_device_t结构体<br>多少个.so，见audio_policy.conf加载上半部，<br>audio_hw_device_t： 音频设备的抽象类。多少个audio_hw_device_t结构体？ 有多少个so，就有多少个。 一一对应关系。<br>audio_stream_out ： 音频设备的输入输出通道的抽象类。这个才是对应pcmc0d0p之类的具体通道，right?<br>至于这些结构体的定义与功能，见HAL相关小节。<br>输出通道打开流程：</p>
<p>输出通道打开流程（上）<br>如AudioRecord.cpp开始：<br>AudioRecord.cpp<br>-&gt;set()<br>-&gt; AudioSystem.getInput()<br>-&gt; 各种辗转<br>-&gt;AudioFlinger-&gt;openInput()</p>
<p>如AudioTrack.cpp开始：<br>AudioTrack.set()<br>-&gt; AudioSystem::getOutput<br>-&gt; 各种辗转<br>-&gt;AudioFlinger-&gt;openOutput()</p>
<p>输出通道打开流程（下）<br>无论上层的打开流程如何辗转反侧，最终都调用到具体执行者AudioFlinger。由此开始分析如下：<br>AudioFlinger如何打开输出通道呢？ 具体是如何调用到alsalib库，甚至驱动的呢？ 接着走。<br>AudioFlinger-&gt;openOutput()<br>-&gt; findSuitableHwDev_l ()<br>//寻找输出设备，返回audio_hw_device_t<br>-&gt; audio_hw_device_t-&gt; open_output_stream(…, struct audio_stream_out **stream_out))<br>//HAL层，Audio架构标准接口<br>-&gt; new audio_stream_out<br>//HAL层，厂商实现类，如device\asus\grouper\audio\audio_hw.c<br>-&gt; audio_stream_out.pcm = pcm_open()<br>// pcm_open() 已经是调用到tinyalsa库了，也就操作到了/dev/snd/pcmcxdxx设备节点了。<br>//所以看到调用层级AudioFlinger -&gt; Audio HAL -&gt; tinyalsa -&gt; ALSA driver -&gt; 硬件。</p>
<p>—————–新版HIDL的实现———————<br>我们可以在hardware/interfaces/audio/2.0/目录下找到部分 Audio HAL 描述文件，如下：<br>Android.bp<br>Android.mk<br>IDevice.hal<br>IDevicesFactory.hal<br>IPrimaryDevice.hal<br>IStream.hal<br>IStreamIn.hal<br>IStreamOutCallback.hal<br>IStreamOut.hal<br>types.hal<br>另外在frameworks/av/media/下多了个文件夹  libaudiohal ：</p>
<p>Android.mk                DeviceHalLocal.h             DevicesFactoryHalLocal.h  EffectHalHidl.h             EffectsFactoryHalLocal.h  StreamHalLocal.h<br>ConversionHelperHidl.cpp  DevicesFactoryHalHidl.cpp    EffectBufferHalHidl.cpp   EffectHalLocal.cpp          HalDeathHandlerHidl.cpp<br>ConversionHelperHidl.h    DevicesFactoryHalHidl.h      EffectBufferHalHidl.h     EffectHalLocal.h            include<br>DeviceHalHidl.cpp         DevicesFactoryHalHybrid.cpp  EffectBufferHalLocal.cpp  EffectsFactoryHalHidl.cpp   StreamHalHidl.cpp<br>DeviceHalHidl.h           DevicesFactoryHalHybrid.h    EffectBufferHalLocal.h    EffectsFactoryHalHidl.h     StreamHalHidl.h<br>DeviceHalLocal.cpp        DevicesFactoryHalLocal.cpp   EffectHalHidl.cpp         EffectsFactoryHalLocal.cpp  StreamHalLocal.cpp<br>从文件名命名方式来看，一类是以Hidl结尾，一类是Local结尾，Local结尾的应该是兼容之前的方式<br>Audio Record 调用分析：<br>(1) Java层调用Android的SDK中的API实例化一个AudioRecord对象</p>
<p>　　-》 \android-8.0.0_r4\frameworks\av\media\libaudioclient\AudioRecord.cpp  -》  AudioRecord::AudioRecord</p>
<p> (2) 设置相应参数 </p>
<p>　　-》 mStatus = set(inputSource, sampleRate, format, channelMask, frameCount, cbf, user,<br>            　　　　　　　　notificationFrames, false /<em>threadCanCallJava</em>/, sessionId, transferType, flags,<br>           　　　　　　 　　uid, pid, pAttributes);</p>
<p> (3)打开录音接口</p>
<pre><code>　-》　// create the IAudioRecord
</code></pre><p>   　　 　　status_t status = openRecord_l(0 /<em>epoch</em>/, mOpPackageName);</p>
<p> (4) 获取输入设备属性：</p>
<p> 　　　　status = AudioSystem::getInputForAttr(&amp;mAttributes, &amp;input,<br>                                        mSessionId,<br>                                        // FIXME compare to AudioTrack<br>                                        mClientPid,<br>                                        mClientUid,<br>                                        &amp;config,<br>                                        mFlags, mSelectedDeviceId, &amp;mPortId);</p>
<p>　　　　 其中是通过获取audio_policy_service建立binder接口:</p>
<p>　　　　 // establish binder interface to AudioPolicy service<br>　　　　 const sp<iaudiopolicyservice> AudioSystem::get_audio_policy_service() </iaudiopolicyservice></p>
<p> (5) 调用AudioPolicyManager的接口 ： \android-8.0.0_r4\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp</p>
<p>　　　aps-&gt;getInputForAttr -》 AudioPolicyManager::getInputForAttr</p>
<p> (6) 根据app传下的参数获取对应的设备类型：</p>
<p>　　device = getDeviceAndMixForInputSource(inputSource, &amp;policyMix); </p>
<p>　　-》Engine::getDeviceForInputSource      (\android-8.0.0_r4\frameworks\av\services\audiopolicy\enginedefault\src\Engine.cpp)</p>
<pre><code>一般录音软件是：AUDIO_SOURCE_MIC  ，google 语音引擎是：AUDIO_SOURCE_VOICE_RECOGNITION
</code></pre><p>　　 再根据当前系统支持的输入设备返回对应的录音设备：（默认的内置mic就是 AUDIO_DEVICE_IN_BUILTIN_MIC）</p>
<p>复制代码<br> if (mForceUse[AUDIO_POLICY_FORCE_FOR_RECORD] == AUDIO_POLICY_FORCE_BT_SCO &amp;&amp;<br>                availableDeviceTypes &amp; AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) {<br>            device = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET;<br>        } else if (availableDeviceTypes &amp; AUDIO_DEVICE_IN_WIRED_HEADSET) {<br>            device = AUDIO_DEVICE_IN_WIRED_HEADSET;<br>        } else if (availableDeviceTypes &amp; AUDIO_DEVICE_IN_USB_HEADSET) {<br>            device = AUDIO_DEVICE_IN_USB_HEADSET;<br>        } else if (availableDeviceTypes &amp; AUDIO_DEVICE_IN_USB_DEVICE) {<br>            device = AUDIO_DEVICE_IN_USB_DEVICE;<br>        } else if (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BUILTIN_MIC) {<br>            device = AUDIO_DEVICE_IN_BUILTIN_MIC;<br>        }<br>复制代码<br>(7) 根据返回的device类型获取对应录音设备：</p>
<p> 　　　　*input = getInputForDevice(device, address, session, uid, inputSource,<br>                           　　    config-&gt;sample_rate, config-&gt;format, config-&gt;channel_mask, flags,<br>                            　　   policyMix);<br> (8) 调用getInputProfile函数根据传进来的声音采样率、声音格式、通道掩码等参数与获得的设备支持的Input Profile比较返回一个与设备Profile匹配的IOProfile-》</p>
<p>　　　　　profile = getInputProfile(device, address,<br>                                  　　　　profileSamplingRate, profileFormat, profileChannelMask,<br>                                 　　　　 profileFlags);<br> (9) 根据返回的profile调用初始化时加载好的client接口：</p>
<p>复制代码<br>status_t status = mpClientInterface-&gt;openInput(profile-&gt;getModuleHandle(),<br>                                                   &amp;input,<br>                                                   &amp;config,<br>                                                   &amp;device,<br>                                                   address,<br>                                                   halInputSource,<br>                                                   profileFlags);<br>复制代码<br>PS: mpClientInterface是由AudioPolicyService中加载对应模块传递过来：</p>
<p>复制代码<br>void AudioPolicyService::onFirstRef()<br>{<br>    {<br>        Mutex::Autolock _l(mLock);</p>
<pre><code>    // start tone playback thread
    mTonePlaybackThread = new AudioCommandThread(String8(&quot;ApmTone&quot;), this);
    // start audio commands thread
    mAudioCommandThread = new AudioCommandThread(String8(&quot;ApmAudio&quot;), this);
    // start output activity command thread
    mOutputCommandThread = new AudioCommandThread(String8(&quot;ApmOutput&quot;), this);

    mAudioPolicyClient = new AudioPolicyClient(this);
    mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient); //对应的模块加载放在AudioPolicyManager的构造函数中   
}
// load audio processing modules
sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = new AudioPolicyEffects();
{
    Mutex::Autolock _l(mLock);
    mAudioPolicyEffects = audioPolicyEffects;
}
</code></pre><p>}<br>复制代码<br> AudioPolicyManager构造函数中根据宏定义判断通过audio_policy.conf还是audio_policy_configuration.xml解析加载对应的so:</p>
<p>复制代码</p>
<p>#ifdef USE_XML_AUDIO_POLICY_CONF<br>    mVolumeCurves = new VolumeCurvesCollection();<br>    AudioPolicyConfig config(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,<br>                             mDefaultOutputDevice, speakerDrcEnabled,<br>                             static_cast<volumecurvescollection *="">(mVolumeCurves));<br>    if (deserializeAudioPolicyXmlConfig(config) != NO_ERROR) {</volumecurvescollection></p>
<p>#else<br>    mVolumeCurves = new StreamDescriptorCollection();<br>    AudioPolicyConfig config(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,<br>                             mDefaultOutputDevice, speakerDrcEnabled);<br>    if ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;<br>            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) {</p>
<p>#endif<br>复制代码<br> 加载模块:</p>
<pre><code>mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());
if (mHwModules[i]-&gt;mHandle == 0) {
    ALOGW(&quot;could not open HW module %s&quot;, mHwModules[i]-&gt;getName());
    continue;
}
</code></pre><p>具体加载过程：</p>
<p>AudioFlinger::loadHwModule_l  </p>
<p>-》mDevicesFactoryHal-&gt;openDevice(name, &amp;dev);</p>
<p>　　-》DevicesFactoryHalHidl::openDevice(const char <em>name, sp<devicehalinterface> </devicehalinterface></em>device) </p>
<p>　　　　-》DevicesFactory::openDevice(IDevicesFactory::Device device, openDevice_cb _hidl_cb) //对应hardware/interfaces/audio/2.0/目录下IDevicesFactory.hal所描述接口</p>
<p>　　　　　　-》loadAudioInterface(moduleName, &amp;halDevice);</p>
<p>　　　　　　　　-》DevicesFactory::loadAudioInterface(const char *if_name, audio_hw_device_t **dev)</p>
<p>复制代码<br> 　 //加载so,后面最终通过dlopen加载了/system/lib/hw/下对应的so。<br>　　rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);<br>    if (rc) {<br>        ALOGE(“%s couldn’t load audio hw module %s.%s (%s)”, <strong>func</strong>,<br>                AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));<br>        goto out;<br>    }<br>　　 //实际调用到了audio_hw.c中adev_open()，只会被调用一次，也就是给硬件模块中的函数指针赋值open()。<br>    rc = audio_hw_device_open(mod, dev);<br>    if (rc) {<br>        ALOGE(“%s couldn’t open audio hw device in %s.%s (%s)”, <strong>func</strong>,<br>                AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));<br>        goto out;<br>    }<br>    if ((<em>dev)-&gt;common.version &lt; AUDIO_DEVICE_API_VERSION_MIN) {<br>        ALOGE(“%s wrong audio hw device version %04x”, <strong>func</strong>, (</em>dev)-&gt;common.version);<br>        rc = -EINVAL;<br>        audio_hw_device_close(*dev);<br>        goto out;<br>    }<br>复制代码</p>
<p> (10) 再回到AudioPolicyManager::getInputForDevice 中的 mpClientInterface-&gt;openInput调用流程：</p>
<p>　　　　AudioFlinger::openInput -》 </p>
<p>　　　　　　AudioFlinger::openInput_l -》</p>
<p>　　　　  　 　　sp<devicehalinterface> inHwHal = inHwDev-&gt;hwDevice();</devicehalinterface></p>
<p>　　　　 　　　   …</p>
<p>　　　　  　　    inHwHal-&gt;openInputStream -》</p>
<p>　　　　   　　　　　DeviceHalHidl::openInputStream</p>
<p>复制代码<br> Return<void> ret = mDevice-&gt;openInputStream(<br>            handle,<br>            hidlDevice,<br>            hidlConfig,<br>            AudioInputFlag(flags),<br>            AudioSource(source),<br>            <a href="Result r, const sp&lt;IStreamIn&gt;&amp; result, const AudioConfig&amp; suggestedConfig">&amp;</a> {<br>                retval = r;<br>                if (retval == Result::OK) {<br>                    *inStream = new StreamInHalHidl(result); //audio_hw.c中adev_open_input_stream的参数stream_in在这里创建并传入<br>                }<br>                HidlUtils::audioConfigToHal(suggestedConfig, config);<br>            });<br>    return processReturn(“openInputStream”, ret, retval);<br>复制代码<br>-》最终调用到了audio_hw.c中的：</void></p>
<p>复制代码<br>static int adev_open_input_stream(struct audio_hw_device <em>dev,<br>                                  audio_io_handle_t handle,<br>                                  audio_devices_t devices,<br>                                  struct audio_config </em>config,<br>                                  struct audio_stream_in *<em>stream_in,<br>                                  audio_input_flags_t flags,<br>                                  const char </em>address __unused,<br>                                  audio_source_t source )<br>复制代码<br>adev_open_input_stream中对sp<streaminhalinterface> *inStream指针的各成员进行赋值，进一步调用底层的接口获取音频数据。</streaminhalinterface></p>
<p>PS：默认使用上层传下来的config参数，也可以手动更新stream_in的参数，比如 采样率：stream_in-&gt;config.rate，自己实现数据获取接口：stream_in-&gt;stream.read = my_read 等;</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/12/Policy-configuration笔记/" rel="next" title="Policy configuration笔记">
                <i class="fa fa-chevron-left"></i> Policy configuration笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/12/AudioTrack分析/" rel="prev" title="AudioTrack分析">
                AudioTrack分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Semiyd</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">234</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">125</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semiyd</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
